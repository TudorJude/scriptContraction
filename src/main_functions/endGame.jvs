handlers.endGame = function(args, context) {
  
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);

  //var wlStat = "01";
  //var wlStatInt = 0;
  //var curWL = "0";
  //if(args.outcome == "rWin")curWL="1";
  //var ps=server.GetPlayerStatistics(
  //{
//     PlayFabId: currentPlayerId,
//     StatisticNames: ["WinLoss"]
//  });
//  if(ps.Statistics.length != 0)
//  {
//      wlStatInt = ps.Statistics[0].Value.toString();
//      //log.debug("wlStatInt " + wlStatInt);
//      wlStat = Number(wlStatInt).toString(2);
//      //log.debug("wlStat " + wlStat);
//  }
//  var wins = 0;
//  var totalGames = 2;
//  var winRatio = 0;
//  //log.debug("wlStat.length " + wlStat.length);
//  var tempString = new Array(wlStat.length);
//  //log.debug("tempString.length " + tempString.length);
//  for(var i = 0 ; i < tempString.length - 1; i++)
//  {
//    tempString[i] = wlStat[i];
//  }
//	tempString[tempString.length-1] = curWL;
//  //log.debug("tempString " + tempString);
//  wlStat = tempString;
//  //log.debug("wlStat " + wlStat);
//	totalGames = wlStat.length;
//  var winStreak = 0;
//  var winStreakTemp = 0;
//	for(var i = 1; i < wlStat.length; i++)
//	{
//		if(wlStat[i] == "1") 
//      {
//        wins++;
//        winStreakTemp++;
//      }
//      else
//      {
//        if(winStreakTemp > winStreak)
//        {
//          winStreak = winStreakTemp;
//        }
//        winStreakTemp = 0;
//      }
//	}
	//log.debug("wlStatNew " + wlStat);

//  winRatio = Math.round( 100* (wins/totalGames));
  //log.debug("winRatio " + winRatio);
  //let's get some relevant title wide data
    var titleDataRequest = server.GetTitleData(
    {
      Key: ["LeagueSubdivisions","SubdivisionTrophyRanges"]
    }
    );
  //let's update user trophies
  var trophyCount = 0;
  var initTrophyCount = 0;
  var tc=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["TrophyCount"]
  });
  if(tc.Statistics.length != 0)
  {
    trophyCount = tc.Statistics[0].Value;
    if(args.debug == true) log.debug("getting trophy count " + tc.Statistics[0].Value);
  }
  trophyCount = Number(trophyCount);
  initTrophyCount = trophyCount;
  var pDat = server.GetUserInternalData(
  {
    PlayFabId: currentPlayerId,
    Keys: ["trophyLose","trophyWin","LastGameOutcome", "LatestStreak"]
  });
  var refund;
  //log.debug("pDat.Data[trophyLose] " + pDat.Data["trophyLose"].Value);
  //log.debug("pDat.Data[trophyWin] " + pDat.Data["trophyWin"].Value);
  if((pDat.Data["trophyLose"] == undefined) || (pDat.Data["trophyWin"] == undefined)) refund = 45;
  else refund = Number(pDat.Data["trophyLose"].Value) + Number(pDat.Data["trophyWin"].Value);
  //log.debug("refund: " + refund);

//previous game data
  var latestStreak = 0;
  var lastMatchOutcome = "Loss";
  if(pDat.Data["LatestStreak"] != undefined) latestStreak = Number(pDat.Data["LatestStreak"].Value);
  if(isNaN(latestStreak) == true) latestStreak = 0;
  if(pDat.Data["LatestStreak"] != undefined) lastMatchOutcome = pDat.Data["LastGameOutcome"].Value;
  if(lastMatchOutcome == undefined) lastMatchOutcome = "Loss";
  
  var dataToUpdate = 
  {
     "quitLastGame" : "false",
     "LastGameOutcome" : "Loss"
  }

  if(args.outcome == "rWin")
  {
  		trophyCount += refund;
      dataToUpdate["LastGameOutcome"] = "Win";
      if(lastMatchOutcome == "Loss") latestStreak = 1;
      else latestStreak ++;      
  }

  dataToUpdate["LatestStreak"] = latestStreak;

  server.UpdateUserInternalData(
      {
          PlayFabId: currentPlayerId,
          Data: dataToUpdate
      });

 var recHeader = JSON.parse(args.recordingHeader);
//let's update the total wins/ total losses statistics
  var ms=server.GetPlayerStatistics( //miscelanious statistics
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["Wins", "TotalGamesCompleted","LongestWinStreak","BestDriftScore", "HighestLeagueReached"]
  }).Statistics;
  var totalGamesCompleted = GetValueFromStatistics(ms, "TotalGamesCompleted", 0);
  totalGamesCompleted = Number(totalGamesCompleted) + 1;
  var totalWins = GetValueFromStatistics(ms, "Wins", 0);
  if(args.outcome == "rWin")
    totalWins = Number(totalWins) + 1;
  var longestStreak = GetValueFromStatistics(ms, "LongestWinStreak", 0);
  var longestStreakVersion = GetVersionFromStatistics(ms, "LongestWinStreak", 0);
  if(Number(longestStreak) < latestStreak) 
  {    
    longestStreak = latestStreak;
    if(Number(longestStreak) == 10)
      publishToLiveFeed(currentPlayerId, "winStreak", 10);
  }
  var bestScore = GetValueFromStatistics(ms, "BestDriftScore", 0);
  if(Number(recHeader.Score) > bestScore)
    bestScore = Number(recHeader.Score);
  //log.debug("trophies change: " + initTrophyCount + " => " + trophyCount);
  var cLeague = calculateLeague(trophyCount);

  var highestLeague = GetValueFromStatistics(ms, "HighestLeagueReached", 1);
  if(cLeague > highestLeague) highestLeague = cLeague;
  //wlStatInt = 0;
  //for(var i = 0 ; i < wlStat.length; i++)
  //{
  //  if(wlStat[i] == "1")
  //    wlStatInt += Math.pow(2,i);
  //}
  //update stats on server
  var suArray = [];
  //var su = {StatisticName : "WinLoss", Version : "0", Value: wlStatInt};
  //suArray.push(su);
  var sut = {StatisticName : "TrophyCount", Value: trophyCount};
  suArray.push(sut);
  var sul = {StatisticName : "League", Value: cLeague};
  suArray.push(sul);
    var suw = {StatisticName : "Wins", Value: totalWins};
  suArray.push(suw);
    var sutg = {StatisticName : "TotalGamesCompleted", Value: totalGamesCompleted};
  suArray.push(sutg);
    var sulws = {StatisticName : "LongestWinStreak", Value: longestStreak};
  suArray.push(sulws);
    var subds = {StatisticName : "BestDriftScore", Value: bestScore};
  suArray.push(subds);
    var subhlr = {StatisticName : "HighestLeagueReached", Value: highestLeague};
  suArray.push(subhlr);
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: suArray
  }
  );
  //user ran out of time so we don't store recording
  //legacy code
  
  if(Number(recHeader.Score) <= 100)
    {
        var newPlayerStats =
        {
          "TrophyCount" : trophyCount,
          "League" : cLeague
        }
        return {Result : newPlayerStats};
    }
  //let's see which Subdivision this player is in
  var sdval = titleDataRequest.Data["SubdivisionTrophyRanges"];
  var sdvalParsed = JSON.parse(sdval);
  //log.debug("SubdivisionTrophyRanges " + sdvalParsed);
  var subDivision = 43;
  for(var i = 0; i < sdvalParsed.subdivisions.length; i++)
  {
  	if(initTrophyCount<sdvalParsed.subdivisions[i])
  	{
		subDivision = i;
		break;
  	}
  }
//log.debug("user is in subdivision " + subDivision);
	//let's save the player's recording
 var dict = [];
    dict.push({
        Key:   args.envIndex+"_"+args.courseIndex+"_RecPos",
        Value: args.recordingPos
    });
      dict.push({
            Key:  args.envIndex+"_"+args.courseIndex+"_RecRot",
        Value: args.recordingRot
    });
       dict.push({
            Key:  args.envIndex+"_"+args.courseIndex+"_RecHeader",
        Value: args.recordingHeader
    });
       //log.debug("updating user read only data ");
  var playerData = server.UpdateUserReadOnlyData(
    {
      PlayFabId: currentPlayerId,
      Data:dict
    }
  );

  //log.debug("updated user read only data for " + currentPlayerId + " " + playerData);
  var titleDataVal = server.GetTitleInternalData(
    {
      Key: "RecSubDivision"+subDivision, //i.e RecSubDivision0,
    }
    );
  var recPool = titleDataVal.Data["RecSubDivision"+subDivision];
  //log.debug("recPool: " + recPool);
  var recArray;
  var titleKeyVal;
  if(recPool == undefined)
  {
  	recArray = [];
  	var recObj =
  	{
  		"e": args.envIndex,
  		"c": args.courseIndex,
  		"uId": currentPlayerId
  	}
  	recArray.push(recObj);
  	titleKeyVal = JSON.stringify(recArray);
  	//log.debug("recArray: " + titleKeyVal);
  }
  else
  {
  	recArray = JSON.parse(recPool);
  	//log.debug("recArray: " + recArray);
  	var recObj =
  	{
  		"e": args.envIndex,
  		"c": args.courseIndex,
  		"uId": currentPlayerId
  	}
  	var uniqueKeyExists = false;
    //let's only keep 2 recordings per user per subdivision at max
    var currentOccurencesOfPlayer = 0;
    for(var i = 0; i < recArray.length; i++)
    {
      if(recArray[i].uId == currentPlayerId)
        currentOccurencesOfPlayer++;
    }
    if(currentOccurencesOfPlayer > 2) // no use letting the user spam his recordings on the same subdivision
    {
      var newPlayerStats =
      {
          "TrophyCount" : trophyCount,
          "League" : cLeague
      }
      return {Result : newPlayerStats};
    }

  	for(var i = 0; i < recArray.length; i++)
  	{
  		if((recArray[i].e == args.envIndex)&&(recArray[i].c == args.courseIndex))
  		{
			 uniqueKeyExists = true;
			 recArray[i] = recObj;
       /*
       //LEGACY WL RATIO SORT
            if(recArray.length == 1) break; //if it's the only recording there is no use to sort anymore
      if(i > 0) // if not first
      {
        if(recArray[i].wl > recArray[i-1].wl) // if bigger than left we start comparing to elements to the right
        {
          if(i == recArray.length-1) break; // there are no more elements to the right so no more sorting required
          for(var j = i + 1; j < recArray.length; j++) // we check elements i+1 to length-1
          {
            if(recArray[j - 1].wl > recArray[j].wl) // if wl of element j - 1 is greater than that of element j we swap them
            {
              var aux = recArray[j];
              recArray[j] = recArray[j - 1];
              recArray[j - 1] = aux;
            }
            else // the element stays where it is
            {
              break;
            }
          }
        }
        else // not bigger than the left let's start comparing with elements to the left
        {
          for(var j = i - 1; j >= 0; j--) // we check elements i-1 to 0
          {
            if(recArray[j + 1].wl < recArray[j].wl) // if wl of element j + 1 is smaller than that of element j we swap them
            {
              var aux = recArray[j];
              recArray[j] = recArray[j + 1];
              recArray[j + 1] = aux;
            }
            else // the element stays where it is
            {
              break;
            }
          }
        }
        } // if(i > 0)
        else
        {
          for(var j = i + 1; j < recArray.length; j++) // we check elements i+1 to length-1
          {
            if(recArray[j - 1].wl > recArray[j].wl) // if wl of element j - 1 is greater than that of element j we swap them
            {
              var aux = recArray[j];
              recArray[j] = recArray[j - 1];
              recArray[j - 1] = aux;
            }
            else // the element stays where it is
            {
              break;
            }
          }
        }
       */
  		}
  	}
  	if(uniqueKeyExists == false)
  	{
  	 // log.debug("recArrayLNbefore: " + recArray.length);
  	  recArray.push(recObj);
  	  //log.debug("recArrayLNafter: " + recArray.length);
    }
  	titleKeyVal = JSON.stringify(recArray);
  //	log.debug("titleKeyVal: " + titleKeyVal);
  }

  var titleData = server.SetTitleInternalData(
    {
      Key: "RecSubDivision"+subDivision, //Recording_0_0
      Value: titleKeyVal
    }
    );
   var newPlayerStats =
     {
          "TrophyCount" : trophyCount,
          "League" : cLeague
      };
  return {Result : newPlayerStats};
}
