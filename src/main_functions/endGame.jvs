handlers.endGame = function(args, context) {
  
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);

  var wlStat = "01";
  var wlStatInt = 0;
  var curWL = "0";
  if(args.outcome == "rWin")curWL="1";
  var ps=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["WinLoss"]
  });
  if(ps.Statistics.length != 0)
  {
      wlStatInt = ps.Statistics[0].Value.toString();
      //log.debug("wlStatInt " + wlStatInt);
      wlStat = Number(wlStatInt).toString(2);
      //log.debug("wlStat " + wlStat);
  }
  var wins = 0;
  var totalGames = 2;
  var winRatio = 0;
  //log.debug("wlStat.length " + wlStat.length);
  var tempString = new Array(wlStat.length);
  //log.debug("tempString.length " + tempString.length);
  for(var i = 0 ; i < tempString.length - 1; i++)
  {
    tempString[i] = wlStat[i];
  }
	tempString[tempString.length-1] = curWL;
  //log.debug("tempString " + tempString);
  wlStat = tempString;
  //log.debug("wlStat " + wlStat);
	totalGames = wlStat.length;
  var winStreak = 0;
  var winStreakTemp = 0;
	for(var i = 0; i < wlStat.length; i++)
	{
		if(wlStat[i] == "1") 
      {
        wins++;
        winStreakTemp++;
      }
      else
      {
        if(winStreakTemp > winStreak)
        {
          winStreak = winStreakTemp;
        }
        winStreakTemp = 0;
      }
	}
	//log.debug("wlStatNew " + wlStat);

  winRatio = Math.round( 100* (wins/totalGames));
  //log.debug("winRatio " + winRatio);
  //let's get some relevant title wide data
    var titleDataRequest = server.GetTitleData(
    {
      Key: ["LeagueSubdivisions","SubdivisionTrophyRanges"]
    }
    );
  //let's update user trophies
  var trophyCount = 0;
  var initTrophyCount = 0;
  var tc=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["TrophyCount"]
  });
  if(tc.Statistics.length != 0)
  {
    trophyCount = tc.Statistics[0].Value;
    log.debug("getting trophy count " + tc.Statistics[0].Value);
  }
  trophyCount = Number(trophyCount);
  initTrophyCount = trophyCount;
  var pDat = server.GetUserInternalData(
  {
    PlayFabId: currentPlayerId,
    Keys: ["trophyLose","trophyWin"]
  });
  var refund;
  //log.debug("pDat.Data[trophyLose] " + pDat.Data["trophyLose"].Value);
  //log.debug("pDat.Data[trophyWin] " + pDat.Data["trophyWin"].Value);
  if((pDat.Data["trophyLose"] == undefined) || (pDat.Data["trophyWin"] == undefined)) refund = 45;
  else refund = Number(pDat.Data["trophyLose"].Value) + Number(pDat.Data["trophyWin"].Value);
  //log.debug("refund: " + refund);
  if(args.outcome == "rWin")
  {
  		trophyCount += refund;
  }
 var recHeader = JSON.parse(args.recordingHeader);
//let's update the total wins/ total losses statistics
  var ms=server.GetPlayerStatistics( //miscelanious statistics
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["Wins", "TotalGamesCompleted","LongestWinStreak","BestDriftScore"]
  });
  var totalGames = GetValueFromStatistics(ms, "TotalGamesCompleted", 0);
  totalGames = Number(totalGames) + 1;
  var totalWins = GetValueFromStatistics(ms, "Wins", 0);
  if(args.outcome == "rWin")
    totalWins = Number(totalWins) + 1;
  var longestStreak = GetValueFromStatistics(ms, "LongestWinStreak", 0);
  if(winStreak > longestStreak)
    longestStreak = winStreak;
  var bestScore = GetValueFromStatistics(ms, "BestDriftScore", 0);
  if(Number(recHeader.Score) > bestScore)
    bestScore = Number(recHeader.Score);
  //log.debug("trophies change: " + initTrophyCount + " => " + trophyCount);
  var cLeague = calculateLeague(trophyCount);
  wlStatInt = 0;
  for(var i = 0 ; i < wlStat.length; i++)
  {
    if(wlStat[i] == "1")
      wlStatInt += Math.pow(2,i);
  }
  //update stats on server
  var suArray = [];
  var su = {StatisticName : "WinLoss", Version : "0", Value: wlStatInt};
  suArray.push(su);
  var sut = {StatisticName : "TrophyCount", Version : "0", Value: trophyCount};
  suArray.push(sut);
  var sut = {StatisticName : "League", Version : "0", Value: cLeague};
  suArray.push(sut);
    var sut = {StatisticName : "Wins", Version : "0", Value: totalWins};
  suArray.push(sut);
    var sut = {StatisticName : "TotalGamesCompleted", Version : "0", Value: totalGames};
  suArray.push(sut);
    var sut = {StatisticName : "LongestWinStreak", Version : "0", Value: longestStreak};
  suArray.push(sut);
    var sut = {StatisticName : "BestDriftScore", Version : "0", Value: bestScore};
  suArray.push(sut);
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: suArray
  }
  );
  //user ran out of time so we don't store recording
  //legacy code
  
  if(Number(recHeader.Score) <= 10)
    {
        var newPlayerStats =
        {
          "TrophyCount" : trophyCount,
          "League" : cLeague
        }
        return {Result : newPlayerStats};
    }
  //let's see which Subdivision this player is in
  var sdval = titleDataRequest.Data["SubdivisionTrophyRanges"];
  var sdvalParsed = JSON.parse(sdval);
  //log.debug("SubdivisionTrophyRanges " + sdvalParsed);
  var subDivision;
  for(var i = 0; i < sdvalParsed.subdivisions.length; i++)
  {
  	if(initTrophyCount<sdvalParsed.subdivisions[i])
  	{
		subDivision = i;
		break;
  	}
  }
//log.debug("user is in subdivision " + subDivision);
	//let's save the player's recording
 var dict = [];
    dict.push({
        Key:   args.envIndex+"_"+args.courseIndex+"_RecPos",
        Value: args.recordingPos
    });
      dict.push({
            Key:  args.envIndex+"_"+args.courseIndex+"_RecRot",
        Value: args.recordingRot
    });
       dict.push({
            Key:  args.envIndex+"_"+args.courseIndex+"_RecHeader",
        Value: args.recordingHeader
    });
       //log.debug("updating user read only data ");
  var playerData = server.UpdateUserReadOnlyData(
    {
      PlayFabId: currentPlayerId,
      Data:dict
    }
  );

  //log.debug("updated user read only data for " + currentPlayerId + " " + playerData);
  var titleDataVal = server.GetTitleInternalData(
    {
      Key: "RecSubDivision"+subDivision, //i.e RecSubDivision0,
    }
    );
  var recPool = titleDataVal.Data["RecSubDivision"+subDivision];
  //log.debug("recPool: " + recPool);
  var recArray;
  var titleKeyVal;
  if(recPool == undefined)
  {
  	recArray = [];
  	var recObj =
  	{
  		"wl": winRatio,
  		"e": args.envIndex,
  		"c": args.courseIndex,
  		"uId": currentPlayerId
  	}
  	recArray.push(recObj);
  	titleKeyVal = JSON.stringify(recArray);
  	//log.debug("recArray: " + titleKeyVal);
  }
  else
  {
  	recArray = JSON.parse(recPool);
  	//log.debug("recArray: " + recArray);
  	var recObj =
  	{
  		"wl": winRatio,
  		"e": args.envIndex,
  		"c": args.courseIndex,
  		"uId": currentPlayerId
  	}
  	var uniqueKeyExists = false;
    //let's only keep 2 recordings per user per subdivision at max
    var currentOccurencesOfPlayer = 0;
    for(var i = 0; i < recArray.length; i++)
    {
      if(recArray[i].uId == currentPlayerId)
        currentOccurencesOfPlayer++;
    }
    if(currentOccurencesOfPlayer > 2) // no use letting the user spam his recordings on the same subdivision
    {
      var newPlayerStats =
      {
          "TrophyCount" : trophyCount,
          "League" : cLeague
      }
      return {Result : newPlayerStats};
    }

  	for(var i = 0; i < recArray.length; i++)
  	{
  		if((recArray[i].e == args.envIndex)&&(recArray[i].c == args.courseIndex))
  		{
			uniqueKeyExists = true;
			recArray[i] = recObj;
			if(recArray.length == 1) break; //if it's the only recording there is no use to sort anymore
			if(i > 0) // if not first
			{
				if(recArray[i].wl > recArray[i-1].wl) // if bigger than left we start comparing to elements to the right
				{
					if(i == recArray.length-1) break; // there are no more elements to the right so no more sorting required
					for(var j = i + 1; j < recArray.length; j++) // we check elements i+1 to length-1
					{
						if(recArray[j - 1].wl > recArray[j].wl) // if wl of element j - 1 is greater than that of element j we swap them
						{
							var aux = recArray[j];
							recArray[j] = recArray[j - 1];
							recArray[j - 1] = aux;
						}
						else // the element stays where it is
						{
							break;
						}
					}
				}
				else // not bigger than the left let's start comparing with elements to the left
				{
					for(var j = i - 1; j >= 0; j--) // we check elements i-1 to 0
					{
						if(recArray[j + 1].wl < recArray[j].wl) // if wl of element j + 1 is smaller than that of element j we swap them
						{
							var aux = recArray[j];
							recArray[j] = recArray[j + 1];
							recArray[j + 1] = aux;
						}
						else // the element stays where it is
						{
							break;
						}
					}
				}
		    } // if(i > 0)
		    else
		    {
					for(var j = i + 1; j < recArray.length; j++) // we check elements i+1 to length-1
					{
						if(recArray[j - 1].wl > recArray[j].wl) // if wl of element j - 1 is greater than that of element j we swap them
						{
							var aux = recArray[j];
							recArray[j] = recArray[j - 1];
							recArray[j - 1] = aux;
						}
						else // the element stays where it is
						{
							break;
						}
					}
		    }
  		}
  	}
  	if(uniqueKeyExists == false)
  	{
  	 // log.debug("recArrayLNbefore: " + recArray.length);
  	  recArray.push(recObj);
  	  //log.debug("recArrayLNafter: " + recArray.length);
    }
  	titleKeyVal = JSON.stringify(recArray);
  //	log.debug("titleKeyVal: " + titleKeyVal);
  }

  var titleData = server.SetTitleInternalData(
    {
      Key: "RecSubDivision"+subDivision, //Recording_0_0
      Value: titleKeyVal
    }
    );
   var newPlayerStats =
     {
          "TrophyCount" : trophyCount,
          "League" : cLeague
      };
  return {Result : newPlayerStats};
}
