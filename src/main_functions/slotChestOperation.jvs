handlers.slotChestOperation = function(args,context)
{
	//CHEST SLOTS INFO
	//SLOTS HAVE 4 STATES: 
	//"Empty" <- no chest, chestID will be null
	//"Occupied" <- chest in standard state
	//"Incoming" <- chest that has been "ordered" and will arrive in set amount of time set in each chests custom data in "Chests" catalog data. Only 1 chest may be "Incoming" at any one time
	//"Arrived" <- chest that is openable as a result of waiting the "Incoming" period or performing the "rush".

	//let's get the user's slots chest info
	var chestData = server.GetUserInternalData(
	{
		PlayFabId : currentPlayerId,
		Keys : ["ChestSlotsStatus"]
	});

	//check user slots data validity.
	if(chestData.Data.ChestSlotsStatus == undefined) return generateErrObj("No Chest Data found!");

	var slotArray = JSON.parse(chestData.Data.ChestSlotsStatus.Value);

	//check slot idx is within range
	if((Number(args.slotIndex) >= slotArray.length) || (Number(args.slotIndex) < 0)) return generateErrObj("Invalid slot index");

	var operation = args.operation;
	//check if slot is
	if(slotArray[(Number(args.slotIndex))].status == "Empty") return generateFailObjCustom("ChestSlotInfo", JSON.parse(chestData.Data.ChestSlotsStatus.Value)); // there is no chest in this slot. Refresh the client's chest slot info status

	//let's now get the chests catalogData
	var catalogData = server.GetCatalogItems({CatalogVersion : "Chests"});

	switch (operation)
	{
		//"order" works only on "Occupied" slot state
		//after succesfull operation slot state changes to "Incoming"
		case "order" :
		{
			//let's check if there are any other chests in "Incoming State"
			for(var i = 0; i < slotArray.length; i++)
			{
				if(slotArray[i].status == "Incoming") return generateFailObjCustom("ChestSlotInfo", JSON.parse(chestData.Data.ChestSlotsStatus.Value)); // there is already a chest in "Incoming state". Refresh the client's chest slot info status
			}

			//only slots that are in state "Occupied" may be set ordered and set to "Incoming" state
			if(slotArray[(Number(args.slotIndex))].status != "Occupied") return generateFailObjCustom("ChestSlotInfo", JSON.parse(chestData.Data.ChestSlotsStatus.Value)); // there is no chest in this slot. Refresh the client's chest slot info status

			slotArray[(Number(args.slotIndex))].status = "Incoming";	
			var d = new Date();	
			slotArray[(Number(args.slotIndex))].orderTimeStamp = Math.floor(Number(d.getTime()) / 1000);
			//let's get the catalog data for our slot's chest
			// we require: hoursToOpen (splitable array)
			var hoursToOpen;
			var chestInfo;
			for(var i = 0; i < catalogData.Catalog.length; i++)
			{
				if(catalogData.Catalog[i].ItemId == slotArray[(Number(args.slotIndex))].chestId)
				{
					chestInfo = JSON.parse(catalogData.Catalog[i].CustomData);
					var hoursToOpenArr = chestInfo.hoursToOpen.split(",");
					if(slotArray[(Number(args.slotIndex))].chestLeague == "0") // arena 0 has same opening time as arena 1 exception
						hoursToOpen = Number(hoursToOpenArr[0]);
					else
						hoursToOpen = Number(hoursToOpenArr[Math.min(Number(slotArray[(Number(args.slotIndex))].chestLeague), hoursToOpenArr.length - 1)]);
				}
			}
			log.debug("hoursToOpen: " + hoursToOpen);
			slotArray[(Number(args.slotIndex))].arrivalTimeStamp = Number(slotArray[(Number(args.slotIndex))].orderTimeStamp) + Math.floor(hoursToOpen * 3600);
			if(chestInfo == undefined) return generateErrObj("Could not find chest with id: " + slotArray[(Number(args.slotIndex))].chestId + " in the Chests catalog, or this chest's custom data is undefined");

			//let's update the user's chest slot data
			var chestSlotInfoString = JSON.stringify(slotArray);
			server.UpdateUserInternalData(
			{
				PlayFabId: currentPlayerId,
				Data: 
				{
					"ChestSlotsStatus" : chestSlotInfoString
				}
			});

			var r = {
				"Result" : "OK",
				"ChestSlotInfo" : slotArray
			}

			return r;

		}
		break;

		//"rush" works on "Occupied" slot state or on "Incoming" slot state with reduced cost proportional with time passed of the total time needed for chest to change from "Incoming" to "Arrived"
		//after succesfull operation slot state changes to "Arrived"
		case "rush" :
		{
			//only slots that are in state that are not "Arrived" or "Empty" may be set ordered and set to "Incoming" state. We already checked for "Empty" prior
			if(slotArray[(Number(args.slotIndex))].status == "Arrived") return generateFailObjCustom("ChestSlotInfo", JSON.parse(chestData.Data.ChestSlotsStatus.Value)); // invalid operation on this slot

			// let's get the catalog data for our slot's chest
			// we require: hoursToOpen (splitable array) and priceToUnlock (Number)
			var priceToUnlock;
			var hoursToOpen; //total
			var chestInfo;
			for(var i = 0; i < catalogData.Catalog.length; i++)
			{
				if(catalogData.Catalog[i].ItemId == slotArray[(Number(args.slotIndex))].chestId)
				{
					chestInfo = JSON.parse(catalogData.Catalog[i].CustomData);
					priceToUnlock = Number(chestInfo.priceToUnlock);
					var hoursToOpenArr = chestInfo.hoursToOpen.split(",");
					if(slotArray[(Number(args.slotIndex))].chestLeague == 0) // arena 0 has same opening time as arena 1 exception
						hoursToOpen = Number(hoursToOpenArr[0]);
					else
						hoursToOpen = Number(hoursToOpenArr[Math.min(Number(slotArray[(Number(args.slotIndex))].chestLeague), hoursToOpenArr.length - 1)]);
				}
			}

			var r; // return result

			//let's calculate the amount of gold user needs to spend to rush this chest in case it's in the "Incoming state"
			var d = new Date();
			var t = 0; // interpolator
			if(slotArray[(Number(args.slotIndex))].status == "Occupied") // if we rush an "Occupied" state slot rushPrice = priceToUnlock and therefore the interpolator will be 1.
				t = 1;
			else //"Incoming" state
				t = (Number(slotArray[(Number(args.slotIndex))].arrivalTimeStamp) - Math.floor(Number(d.getTime()) / 1000)) / (hoursToOpen * 3600);

			log.debug("interpolator: " + t);
			if(t <= 0) //this means that the chest had arrived already. This may happen on rare occasions when client and server are a few seconds out of sync
			{
				slotArray[(Number(args.slotIndex))].status = "Arrived";
				slotArray[(Number(args.slotIndex))].arrivalTimeStamp = 0; // set this for the client

				r = {
				    Result: "OK",
				    ChestSlotInfo : slotArray
				  };
			}
			else
			{
				var rushPrice = Math.floor(1 + t * (priceToUnlock - 1));

				log.debug("rushPrice: " + rushPrice);

				//we now have to querry the user's inventory to see if he has enough currency to rush the chest
				var userInventoryObject = server.GetUserInventory(
			    {
			      PlayFabId: currentPlayerId
			    });

			    if(rushPrice > userInventoryObject.VirtualCurrency.HC) return generateErrObj("Not enough HC.");

			    //let's set the user's chest slot info to "Arrived"
			    slotArray[(Number(args.slotIndex))].status = "Arrived";
				slotArray[(Number(args.slotIndex))].arrivalTimeStamp = 0; // set this for the client
				slotArray[(Number(args.slotIndex))].orderTimeStamp = 1; // set this for the client

			    //let's subtract rushPrice amount of gold from the user
			    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
		        {
		          PlayFabId: currentPlayerId,
		          VirtualCurrency : "HC",
		          Amount: rushPrice
		        });
		        //update the CurrencySpent stat for this user
			    updateCurrencySpentStatistic("HC", rushPrice);

			    var currencyUpdated = {};
			    currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
			    var i =
			      {
			        VirtualCurrency: currencyUpdated
			      };

			     r = {
				    Result: "OK",
				    InventoryChange:i,
				    ChestSlotInfo : slotArray
				  };
			}

			//let's update the user's chest slot data
			var chestSlotInfoString = JSON.stringify(slotArray);
			server.UpdateUserInternalData(
			{
				PlayFabId: currentPlayerId,
				Data: 
				{
					"ChestSlotsStatus" : chestSlotInfoString
				}
			});

			return r;
		}
		break;

		case "open" :
		{
			var slotIndex = Number(args.slotIndex);
			var chestInfo;
			for(var i = 0; i < catalogData.Catalog.length; i++)
			{
				if(catalogData.Catalog[i].ItemId == slotArray[(Number(args.slotIndex))].chestId)
				{
					chestInfo = JSON.parse(catalogData.Catalog[i].CustomData);
					break;
				}
			}
			if(chestInfo == undefined) return generateErrObj("Could not find chest with id: " + slotArray[(Number(args.slotIndex))].chestId + " in the Chests catalog, or this chest's custom data is undefined");
			if(slotArray[slotIndex].status == "Empty") return generateFailObjCustom("ChestSlotInfo", JSON.parse(chestData.Data.ChestSlotsStatus.Value)); // invalid operation on this slot
			if(slotArray[slotIndex].status == "Occupied") return generateFailObjCustom("ChestSlotInfo", JSON.parse(chestData.Data.ChestSlotsStatus.Value)); // invalid operation on this slot
			if((slotArray[slotIndex].status == "Incoming") && (slotArray[slotIndex].arrivalTimeStamp > Math.floor((new Date().getTime() /1000)))) return generateFailObjCustom("ChestSlotInfo", JSON.parse(chestData.Data.ChestSlotsStatus.Value)); // invalid operation on this slot
			var chestBounty = GenerateChestBounty(currentPlayerId, slotArray[slotIndex].chestId, slotArray[slotIndex].chestLeague, chestInfo);
			var returnObject = {
				Result : "OK",
				ChestBounty : chestBounty 
			}

			slotArray[slotIndex].chestId = null;
			slotArray[slotIndex].chestLeague = 0;
			slotArray[slotIndex].status = "Empty";
			slotArray[slotIndex].orderTimeStamp = 0;
			slotArray[slotIndex].arrivalTimeStamp = 0;

			//let's update the user's chest slot data
			var chestSlotInfoString = JSON.stringify(slotArray);
			server.UpdateUserInternalData(
			{
				PlayFabId: currentPlayerId,
				Data: 
				{
					"ChestSlotsStatus" : chestSlotInfoString
				}
			});

			return returnObject;
		}
		break;

	}

}

//this function will return the contents of a chests that's been opened and grant them to the user's inventory
// args
// chestOd <- string id of chest i.e. "SilverChest" as found in the Chests Economy Catalog
// cheastLeague <- league of chest
// chestInfo <- Custom chest info found in catalog data for this particular chest. Must be passed as argument
function GenerateChestBounty(currentPlayerId, chestId, league, chestInfo)
{
	var itemData = {"Amount" : 3};
	dataChanged = 
	[
      {
        ItemId : "Engine",
        CatalogVersion: "PartCards",
        CustomData: {"Amount" : 13}
      },
      {
        ItemId : "Exhaust",
        CatalogVersion: "PartCards",
        CustomData: {"Amount" : 32}
      },
      {
        ItemId : "Gearbox",
        CatalogVersion: "PartCards",
        CustomData: {"Amount" : 123}
      },
      {
        ItemId : "Suspension",
        CatalogVersion: "PartCards",
        CustomData: {"Amount" : 1}
      },
      {
        ItemId : "Tires",
        CatalogVersion: "PartCards",
        CustomData: {"Amount" : 0}
      },
      {
        ItemId : "Turbo",
        CatalogVersion: "PartCards",
        CustomData: {"Amount" : 5}
      },
      {
        ItemId : "AcuraNSX",
        CatalogVersion: "CarCards",
        CustomData: {"Amount" : 7}
      },
      {
        ItemId : "BMWM3-1988",
        CatalogVersion: "CarCards",
        CustomData: {"Amount" : 3}
      },
      {
        ItemId : "SubaruImpreza",
        CatalogVersion: "CarCards",
        CustomData: {"Amount" : 13}
      },
      {
        ItemId : "CorvetteC7",
        CatalogVersion: "CarCards",
        CustomData: {"Amount" : 113}
      },
      {
        ItemId : "MitsubishiEclipse",
        CatalogVersion: "CarCards",
        CustomData: {"Amount" : 3}
      },
      {
        ItemId : "NissanNavara",
        CatalogVersion: "CarCards",
        CustomData: {"Amount" : 3}
      },
      {
        ItemId : "ToyotaLandCruiser70",
        CatalogVersion: "CarCards",
        CustomData: {"Amount" : 3}
      }
	];
	currencyUpdated ={"HC":1500,"SC":1234};
   var chestItems = 
	{
		Inventory: dataChanged,
        VirtualCurrency: currencyUpdated
	};
	return chestItems;
}

//function will fill an empty chest slot with the appropriate chest
// args
// currentPlayerId <- user's playFab ID
// source <- where the chest came from : "endGameNormal", "endGameFreeWin" or "tutorial"
function grantUserChest(currentPlayerId, source)
{
	//let's get the chests catalog data
	var catalogData = server.GetCatalogItems({CatalogVersion : "Chests"});

	//let's also get the user's chest slot info data
	var chestData = server.GetUserInternalData(
	{
		PlayFabId : currentPlayerId,
		Keys : ["ChestSlotsStatus"]
	});

	//check user slots data validity.
	if(chestData.Data.ChestSlotsStatus == undefined) return generateErrObj("No Chest Data found!");

	var slotArray = JSON.parse(chestData.Data.ChestSlotsStatus.Value);

	var slotIndex = -1; //what's the slot index that this operation will fill with a chest? if -1 then all slots are full
	//let's check if there are any Empty slots. If not then we give the user nothing
	for(var i = 0; i < slotArray.length; i++)
	{
		if(slotArray[i].status == "Empty") 
			{
				slotIndex = i;
				break;
			}
	}	

	if(slotIndex < 0) return; // we found no empty slot. No further operations necessary
	log.debug("emptySlotFound: " + slotIndex);
	//we need the trophy count to calculate the league the user is in
	var tc=server.GetPlayerStatistics(
	  {
	     PlayFabId: currentPlayerId,
	     StatisticNames: ["TrophyCount"]
	  });
	var trophyCount = 0;
	if(tc.Statistics.length != 0)
	  {
	    trophyCount = tc.Statistics[0].Value;
	  }
	trophyCount = Number(trophyCount);
	var cLeague = Number(calculateLeague(trophyCount));
	log.debug("cLeague: " + cLeague);
	log.debug("source: " + source);
	//the source can be "endGameNormal", "endGameFreeWin" and "tutorial"
	switch(source)
	{
		case "endGameNormal" : // we examine all the chests' "dropChance" variable and decide which will drop and fill the user's slot 
		{
			var chestInfo;
			var sumOfWeights = 0;
			var leftRange =0;
			var rightRange = 0;
			var chestWeightsArray = [];
			for(var i = 0; i < catalogData.Catalog.length; i++)
			{
				chestInfo = JSON.parse(catalogData.Catalog[i].CustomData);
				if(Number(chestInfo.dropChance) <= 0) continue; // this chest will never be added to a slot in this manner
				sumOfWeights += Number(chestInfo.dropChance) * 10; //we multiply by 10 for drop chances that have a decimal point
				leftRange = rightRange;
				rightRange = sumOfWeights; 
				log.debug("chest id with drop chance found: " + catalogData.Catalog[i].ItemId);
				var chestItem = 
				{
					"chestId" : catalogData.Catalog[i].ItemId,
					"leftRange" : leftRange,
					"rightRange" : rightRange
				}
				chestWeightsArray.push(chestItem);
			}
			if(chestWeightsArray.length <= 0) // if for whatever reason the chestWeightArray is 0 we will grant the user the "SilverChest"
			{
				slotArray[slotIndex].chestId = "SilverChest";
				log.debug("0 chestWeightsArrayLn");
			}
			else
			{
				log.debug("chestWeightsArray: " + JSON.stringify(chestWeightsArray));
				log.debug("sumOfWeights: " + sumOfWeights);
				//calculate what chest will occupy slot based on ChestWeightArray
				var randVal = Math.floor(Math.random() * sumOfWeights);
				log.debug("randVal: " + randVal);
				var chestFound = "SilverChest";
				for(var i = 0; i < chestWeightsArray.length; i++)
				{
					if(Number(chestWeightsArray[i].rightRange) <= Number(randVal)) continue;
					if(Number(chestWeightsArray[i].leftRange) > Number(randVal)) continue;
					chestFound = chestWeightsArray[i].chestId;
					log.debug("chestFoundAfterWeights: " + chestFound);
					break;
				}
				slotArray[slotIndex].chestId = chestFound;
				log.debug("finalCHest: " + chestFound);
			}

			slotArray[slotIndex].chestLeague = cLeague;
			slotArray[slotIndex].status = "Occupied";
			slotArray[slotIndex].orderTimeStamp = 0;
			slotArray[slotIndex].arrivalTimeStamp = 0;


		}break;
		case "endGameFreeWin" :
		{
			slotArray[slotIndex].chestId = "QuickChest";
			slotArray[slotIndex].chestLeague = cLeague;
			slotArray[slotIndex].status = "Occupied";
			slotArray[slotIndex].orderTimeStamp = 0;
			slotArray[slotIndex].arrivalTimeStamp = 0;
		}break;
		case "tutorial" :
		{
			slotArray[slotIndex].chestId = "QuickChest";
			slotArray[slotIndex].chestLeague = cLeague;
			slotArray[slotIndex].status = "Occupied";
			slotArray[slotIndex].orderTimeStamp = 0;
			slotArray[slotIndex].arrivalTimeStamp = 0;
		}break;
		default:
		{
			log.debug("unexpected source, returning from grantChest");
			return;
		}
		break;
	}

	//let's update the user's chest slot data
	var chestSlotInfoString = JSON.stringify(slotArray);
	log.debug("updating ChestSlotsStatus: " + chestSlotInfoString);
		server.UpdateUserInternalData(
		{
			PlayFabId: currentPlayerId,
			Data: 
			{
				"ChestSlotsStatus" : chestSlotInfoString
			}
		});

}
