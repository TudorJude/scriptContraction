function checkCarDataValidity(inventoryCarData, carCardsCatalog)
{
  if(inventoryCarData.CustomData == undefined)
  {
    try
    {
      var CarData = {
        "CarLvl" : "1",
        "EngineLvl" : "0",
        "ExhaustLvl" : "0",
        "GearboxLvl" : "0",
        "SuspensionLvl" : "0"
      };

      server.UpdateUserInventoryItemCustomData(
        {
          PlayFabId: currentPlayerId,
          ItemInstanceId: inventoryCarData.ItemInstanceId,
          Data: CarData
        }
      );
      CarData = {
        "TiresLvl" : "0",
        "TurboLvl" : "0",
        "PaintId" : "0",
        "DecalId" : "0",
        "RimsId" : "0"
      };
      server.UpdateUserInventoryItemCustomData(
        {
          PlayFabId: currentPlayerId,
          ItemInstanceId: inventoryCarData.ItemInstanceId,
          Data: CarData
        }
      );
      var pr = 0;
      for(var i =0; i < carCardsCatalog.Catalog.length; i++)
      {
        if(carCardsCatalog.Catalog[i].ItemId == inventoryCarData.ItemId)
        {
          var carCardInfo = JSON.parse(carCardsCatalog.Catalog[i].CustomData);
          pr = parseInt(carCardInfo.basePr);
          break;
        }
      }
      CarData = {
        "PlatesId" : "0",
        "WindshieldId" : "0",
        "Pr" : pr
      };
      server.UpdateUserInventoryItemCustomData(
        {
          PlayFabId: currentPlayerId,
          ItemInstanceId: inventoryCarData.ItemInstanceId,
          Data: CarData
        }
      );
    }
    catch(err)
    {
      return "PlayFabError";
    }
    var newData = {
      "CarLvl" : "1",
      "EngineLvl" : "0",
      "ExhaustLvl" : "0",
      "GearboxLvl" : "0",
      "SuspensionLvl" : "0",
      "TiresLvl" : "0",
      "TurboLvl" : "0",
      "PaintId" : "0",
      "DecalId" : "0",
      "RimsId" : "0" ,
      "PlatesId" : "0",
      "WindshieldId" : "0",
      "Pr" : pr
    };
    return newData;
  }
  return "OK";
}
function generateFailObj(mess)
{
  var retObj = {
    Result: "Failed",
    Message: mess
  };
  return retObj;
}

function generateErrObj(mess)
{
  var retObj = {
    Result: "Error",
    Message: mess
  };
  return retObj;
}

function CheckMaintenanceAndVersion(args)
{    
    var debugMode = false;
    var clientVersion = "A.0.0.1";

    if(args != undefined) 
    {
      debugMode = args.debug;
      clientVersion = args.cVersion;
    }

    if(clientVersion == undefined) return "update"; // user has earlier build that doesn't send version to server with each call

    var maintenanceData = server.GetTitleData(
    {
      Key: ["Maintenance", "MinimumGameVersionActual_IOS", "MinimumGameVersionActual"]
    }
    );

    var versionToCompareTo = maintenanceData.Data["MinimumGameVersionActual"];
    var versionData = clientVersion.split(".");
    if(versionData.length != 4) return "maintenance"; // version data exists but it's corrupted
    if(versionData[0] == "ios") versionToCompareTo = maintenanceData.Data["MinimumGameVersionActual_IOS"];
    if(versionToCompareTo == undefined) return "maintenance"; // the title data isn't there so it's safe to assume the server isn't safe and it is in maintenance mode
    //needs update code
    var needsUpdate = false;

    var minGameVerSplit = versionToCompareTo.split('.');
    for (var i = 0; i < 3; i++)
    {
          var currVer = 0;
          if (versionData.length > i + 1)
                  currVer = Number(versionData[i + 1]);
          var minVer = 0;
          if (minGameVerSplit.length > i)
                  minVer = Number(minGameVerSplit[i]);

          //log.debug("iteration: " + i + " currVer: " + currVer + " vs minVer: " + minVer);

          if (currVer < minVer)
          {
              needsUpdate = true;
              break;
          }    
    }
    // end needs update code
    if(needsUpdate == true) return "update";
    if(debugMode == true) return "OK"; // maintenance is bypassed by debug clients
    if(maintenanceData.Data["Maintenance"]) 
    {
      if(maintenanceData.Data["Maintenance"] == "false") return "OK";
      else return "maintenance";
    }
    else return "maintenance";
}

function generateMaintenanceOrUpdateObj(action)
{
  var retObj;
  if(action == "maintenance")
    retObj = {
      Result: "Maintenance",
      Message: "Servers are temporarily offline"
    };
  else
      retObj = {
      Result: "Update",
      Message: "Game needs to be updated"
    };
  return retObj;
}

function generateInventoryChange(mess, inventory)
{
  var r = {
    Result: "OK",
    Message: mess,
    InventoryChange:inventory
  };
  return r;
}

function updateCurrencySpentStatistic(currType, amount)
{
  var suArray = [];
  var statName;
  var currValue = 0;
  var changeValue = Number(amount);
  if(isNaN(changeValue) || changeValue <= 0) return;
  if(currType == "SC") statName = "MoneySpent";
  if(currType == "HC") statName = "GoldSpent";
  if(statName == undefined) return;
    var ps=server.GetPlayerStatistics(
    {
       PlayFabId: currentPlayerId,
       StatisticNames: [statName]
    });
    if(ps.Statistics.length > 0)
    {
        currValue = Number(ps.Statistics[0].Value);
    }  
    currValue += changeValue;
    var su = {StatisticName: statName, Version : "0", Value: currValue};
    suArray.push(su);
    var updateRequest = server.UpdatePlayerStatistics(
      {
         PlayFabId: currentPlayerId,
         Statistics: suArray
      }
      );
}

function checkBalance(currType, cost, userSCBalance, userHCBalance)
{
  if(currType == "SC")
  {
    if(userSCBalance < cost)
    return generateFailObj("NotEnoughSC");
  }
  else
  {
    if(userHCBalance < cost)
    return generateFailObj("NotEnoughHC");
  }
  return "OK";
}

function calculateLeague(currentTrophies)
{
  var league = 1;
  var td = server.GetTitleData(
    {
      Keys : ["LeagueSubdivisions", "SubdivisionTrophyRanges"]
    });
    if(td.Data["LeagueSubdivisions"] == undefined) return league;
    if(td.Data["SubdivisionTrophyRanges"] == undefined) return league;
    var leaguesSubdivisions = JSON.parse(td.Data.LeagueSubdivisions);
    var leaguesSubdivisionsParsed = leaguesSubdivisions.leagues;
    var sdvtr = JSON.parse(td.Data.SubdivisionTrophyRanges);
    var sdvtrParsed = sdvtr.subdivisions;

    for(var i = 0; i < leaguesSubdivisionsParsed.length; i++)
    {
      if(Number(currentTrophies) > Number(sdvtrParsed[leaguesSubdivisionsParsed[i]]))
      continue;
      return i;
    }
    return leaguesSubdivisionsParsed.length - 1;
  }

  function recalculateCarPr(CarData, carId, _carCardsCatalog, _partsCardCatalog)
  {
    var pr = 0;
    var carCardsCatalog;
    if(_carCardsCatalog === undefined)
    {
      carCardsCatalog = server.GetCatalogItems(
        {
          CatalogVersion : "CarCards"
        }
      );
    }
    else
    {
      carCardsCatalog = _carCardsCatalog;
    }
    for(var i = 0; i < carCardsCatalog.Catalog.length; i++)
    {
      if(carCardsCatalog.Catalog[i].ItemId == carId)
      {
        var carCardInfo = JSON.parse(carCardsCatalog.Catalog[i].CustomData);
        pr = parseInt(carCardInfo.basePr) + getObjectValueFromLevel(carCardInfo, "prPerLvl", CarData.CarLvl);
        break;
      }
    }

    //calcualte pr based on each part level
    var partCardsCatalog;
    if(_partsCardCatalog === undefined)
    {
      partCardsCatalog = server.GetCatalogItems(
        {
          CatalogVersion : "PartCards"
        }
      );
    }
    else
    {
      partCardsCatalog = _partsCardCatalog;
    }

    var tempDict =
    {
      Exhaust: CarData.ExhaustLvl,
      Engine: CarData.EngineLvl,
      Gearbox: CarData.GearboxLvl,
      Suspension: CarData.SuspensionLvl,
      Tires: CarData.TiresLvl,
      Turbo: CarData.TurboLvl
    };
    var partCardInfo;
    for(i = 0; i < partCardsCatalog.Catalog.length; i++) //refactored
    {
      partCardInfo = JSON.parse(partCardsCatalog.Catalog[i].CustomData);
      pr += getObjectValueFromLevel(partCardInfo, "prPerLvl", Number(tempDict[partCardsCatalog.Catalog[i].ItemId]));
    }
    return pr;
  }

  function GenerateBlackMarket(currentPlayerId)
  {
    //getting user league
    var league = 1;
    var ps=server.GetPlayerStatistics(
      {
        PlayFabId: currentPlayerId,
        StatisticNames: ["League"]
      });
    
      if(ps.Statistics.length != 0)
      {
        league = ps.Statistics[0].Value.toString();
      }
      if(Number(league) <= 0) league = 1; // clamped
      //getting parts
      var partsCatalog = server.GetCatalogItems(
        {
          CatalogVersion : "PartCards"
        }
      );
      //getting bias numbers for rare, common and epic chance
      var tK = ["BlackMarketResetMinutes", "BlackMarketRarityBias"];
      var tData = server.GetTitleData(
        {
          PlayFabId : currentPlayerId,
          Keys : tK
        }
      );
      var bias = tData.Data.BlackMarketRarityBias;
      var biasParsed = JSON.parse(bias);
      //let's create a common parts list, a rare parts list and an epic parts list
      var partCardParsed;
      var commonParts = [];
      var rareParts = [];
      var epicParts = [];
      for(var i = 0; i < partsCatalog.Catalog.length; i++)
      {
        partCardParsed = JSON.parse(partsCatalog.Catalog[i].CustomData)
        if(partCardParsed == undefined) return generateErrObj("Part card " + partsCatalog.Catalog[i].ItemId + " has no custom data.");
        if(partCardParsed.rarity == 0) commonParts.push(partsCatalog.Catalog[i].ItemId + "_" + partCardParsed.BMCurrType + "_" + partCardParsed.BMbasePrice + "_" + 0 + "_" + partCardParsed.BMpriceIncrPerBuy);
        if(partCardParsed.rarity == 1) rareParts.push(partsCatalog.Catalog[i].ItemId + "_" + partCardParsed.BMCurrType + "_" + partCardParsed.BMbasePrice + "_" + 0 + "_" + partCardParsed.BMpriceIncrPerBuy);
        if(partCardParsed.rarity == 2) epicParts.push(partsCatalog.Catalog[i].ItemId + "_" + partCardParsed.BMCurrType + "_" + partCardParsed.BMbasePrice + "_" + 0 + "_" + partCardParsed.BMpriceIncrPerBuy);
      }

      var dataToUpdate = {};
      var d = new Date();
      dataToUpdate["BMTime"] = d.getTime();
      //get first part. It is always common
      var part0Index = Math.floor(Math.random() * commonParts.length);
      dataToUpdate["BMItem0"] = commonParts[part0Index];
      if(commonParts.length >= 2) commonParts.splice(part0Index, 1);
      //generate second car card

      var searchArray = commonParts;
      if(Math.floor(Math.random() * 100) < Number(biasParsed.parts[2])) //biasParsed.parts[2]% chance to be the epic card
        searchArray = epicParts;
      else 
      {
        var newPerc = Number(biasParsed.parts[0]) + Number(biasParsed.parts[1]);
        if (Math.floor(Math.random() * newPerc) >= Number(biasParsed.parts[0])) // this means that it's going to be rare
        {
          searchArray = rareParts;
        }
      }
      var part1Index = Math.floor(Math.random() * searchArray.length);
      dataToUpdate["BMItem1"] = searchArray[part1Index];
      //getting car cards
      var carsCatalog = server.GetCatalogItems(
        {
          CatalogVersion : "CarCards"
        }
      );
      var carCardParsed;
      var commonIndexes = [];
      var rareIndexes = [];
      var epicIndexes = [];
      for(var i = 0; i < carsCatalog.Catalog.length; i++)
      {
        carCardParsed = JSON.parse(carsCatalog.Catalog[i].CustomData)
        if(carCardParsed == undefined) return generateErrObj("Car card " + carsCatalog.Catalog[i].ItemId + " has no custom data.");
        if(Number(carCardParsed.unlockedAtRank) >= (Number(league) + 1)) continue;
        if(carCardParsed.rarity == "0") commonIndexes.push(carsCatalog.Catalog[i].ItemId + "_" + carCardParsed.BMCurrType + "_" + carCardParsed.BMbasePrice + "_" + 0 + "_" + carCardParsed.BMpriceIncrPerBuy);
        if(carCardParsed.rarity == "1") rareIndexes.push(carsCatalog.Catalog[i].ItemId + "_" + carCardParsed.BMCurrType + "_" + carCardParsed.BMbasePrice + "_" + 0 + "_" + carCardParsed.BMpriceIncrPerBuy);
        if(carCardParsed.rarity == "2") epicIndexes.push(carsCatalog.Catalog[i].ItemId + "_" + carCardParsed.BMCurrType + "_" + carCardParsed.BMbasePrice + "_" + 0 + "_" + carCardParsed.BMpriceIncrPerBuy);
      }
      var carIdx = Math.floor(Math.random() * commonIndexes.length);
      dataToUpdate["BMItem2"] = commonIndexes[carIdx];
      if(commonIndexes.length >= 2) commonIndexes.splice(carIdx, 1);

      if(rareIndexes.length <= 0)
      {
        if(epicIndexes.length <= 0)
          {
            rareIndexes = commonIndexes;
            epicIndexes = commonIndexes;
          }
          else
          {
            rareIndexes = epicIndexes;
          }
      }
      if(epicIndexes.length <= 0)
      {
        epicIndexes = rareIndexes;
      }

      var carSearchArray = commonIndexes;
      if(Math.floor(Math.random() * 100) < Number(biasParsed.cars[2])) //biasParsed.cars[2]% chance to be the epic card
        carSearchArray = epicIndexes;
      else 
      {
        var newPerc = Number(biasParsed.cars[0]) + Number(biasParsed.cars[1]);
        if (Math.floor(Math.random() * newPerc) >= Number(biasParsed.cars[0])) // this means that it's going to be rare
        {
          carSearchArray = rareIndexes;
        }
      }

      carIdx = Math.floor(Math.random() * carSearchArray.length);
      dataToUpdate["BMItem3"] = carSearchArray[carIdx];

      server.UpdateUserInternalData(
        {
          PlayFabId : currentPlayerId,
          Data : dataToUpdate
        }
      );
      dataToUpdate["BMTime"] = parseInt(tData.Data.BlackMarketResetMinutes) * 60;
      return dataToUpdate;
    }

    function GetCurrentBlackMarket(currentPlayerId, getInternalDataResult)
    {
      var bmObj = {};
      var d = new Date();

      var tK = [];
      tK.push("BlackMarketResetMinutes");
      var tData = server.GetTitleData(
        {
          PlayFabId : currentPlayerId,
          Keys : tK
        }
      );

      bmObj["BMTime"] = parseInt(tData.Data.BlackMarketResetMinutes) * 60 - Math.floor((d.getTime() - getInternalDataResult.Data.BMTime.Value) / 1000);
      for(var i = 0; i < 4; i++)
      {
        bmObj["BMItem" + i] = getInternalDataResult.Data["BMItem" + i].Value;
      }
      return bmObj;
    }



    /**
    * Returns the statistics value from the provided statistics array
    * @param {array} statisticsArray containing statistics objects
    * @param {string} statisticsName id of the searched statistic
    * @param {value} statisticsName (optional) default value returned if statistic is not found
    */
    function GetValueFromStatistics(statisticsArray, statisticsName, defaultValue)
    {
      var stat;
      //find statistic with given name
      for (var i = 0; i < statisticsArray.length; i++)
      if(statisticsArray[i].StatisticName === statisticsName)
      stat = statisticsArray[i];
  		log.debug("Stat with name statisticsName: " + statisticsName + " is " + stat);
      if(stat === undefined)
      return defaultValue !== undefined ? defaultValue : 0;
      else
      return Number(stat.Value);
    }

    /**
    * Returns catalog item or undifined
    * @param {string} catalogId the catalog id of the requested item
    * @param {string} itemId of the recuested item
    */
    function getCatalogItem(catalogId, itemId)
    {
      var items = server.GetCatalogItems({CatalogVersion : catalogId});
      for (var i = 0; i < items.Catalog.length; i++) {
        if(items.Catalog[i].ItemId === itemId)
        return items.Catalog[i];
      }

      return undefined;
    }


    /**
    * Returns the item value from the object with id itemId at index level
    * The given object must have a 'length' property used to clamp level inbounds
    * @param  {object} holdingObject, object in which itemId is searched
    * @param  {string} itemId, property id of the object that contains the desired value
    * @param  {int} level, index of the desired value
    * @param  {value} defaultValue, 0 if none provided
    * @return {value}, defaultValue or the value at index level in object itemId
    */
    function getObjectValueFromLevel(holdingObject, itemId, level, defaultValue) {
      if(!defaultValue) defaultValue = 0;
      if(!holdingObject[itemId] || !holdingObject[itemId].length) return defaultValue;

      // clamp ln to lenght is it can't get out of bounds
      var ln = Number(holdingObject[itemId].length);
      if(level >= ln) level = ln - 1;
      return Number(holdingObject[itemId][level]) || defaultValue;
    }
handlers.buyChest = function(args, context)
{
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);

  var userInventoryObject=server.GetUserInventory(
  {
    PlayFabId:currentPlayerId
  });

  var bO = checkBalance(args.curr, args.cost, userInventoryObject.VirtualCurrency.SC, userInventoryObject.VirtualCurrency.HC);
  if(bO != "OK") return generateFailObj("not enough money");
  if(args.cost > 0)
  {
    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
    {
      PlayFabId: currentPlayerId,
      VirtualCurrency : args.curr,
      Amount: args.cost
    }
    );
    updateCurrencySpentStatistic(args.curr, args.cost);
    var cU = {};
    cU[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
    return generateInventoryChange("ChestBought", {VirtualCurrency: cU});
  }
  else
  {
    return generateInventoryChange("ChestBought", {});
  }
};
handlers.claimDailyMission = function(args, context) 
{
	var mC = CheckMaintenanceAndVersion(args);
  	if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  	
	var idx = Number(args.mIdx);
	var dStatus = server.GetUserInternalData(
	{
	    PlayFabId: currentPlayerId,
	    Keys: ["DailyMissionStatus"]
	});
	if(dStatus.Data.DailyMissionStatus == undefined)
	{
		return generateErrObj("No daily mission data found on server");
	}
	var parsedData = JSON.parse(dStatus.Data.DailyMissionStatus.Value);
	var DailyMissionClaimStatus = parsedData.dailyMissionClaimStatus;

	if(idx >= DailyMissionClaimStatus.length)
	{
		return generateErrObj("Unlock index is out of bounds of playerData claim mission status array");
	}
	if(DailyMissionClaimStatus[idx] == 1) return generateFailObj("Mission already claimed");
	DailyMissionClaimStatus[idx] = 1;

	var dailyObject = 
	{
		"DailyStatus" : parsedData.DailyStatus,
		"dailyMissionClaimStatus" : DailyMissionClaimStatus,
		"timeStamp" : parsedData.timeStamp
	};
	var dailyObjectStringified = JSON.stringify(dailyObject);
	var objectToUpdate = 
	{
		"DailyMissionStatus" : dailyObjectStringified
	}
	server.UpdateUserInternalData(
       {
          PlayFabId: currentPlayerId,
          Data: objectToUpdate
       });

	var tData = server.GetTitleData(
	    {
	        PlayFabId : currentPlayerId,
	        Keys : ["DailyMissionData"]
	    }
	      );

	var tParsed = JSON.parse(tData.Data.DailyMissionData);

	var rewardCurrency;
	var rewardAmount;
	if(idx >= tParsed.missionData.length)
	{
		return generateErrObj("Unlock index is out of bounds of titleData claim mission reward array");
	}
	var dataArr = tParsed.missionData[idx].split("_");
	rewardCurrency = dataArr[1];
	rewardAmount = Number(dataArr[2]);

	var addUserCurrencyResult = server.AddUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : rewardCurrency,
        Amount: rewardAmount
      }
    );
    var currencyUpdated = {};
    currencyUpdated[addUserCurrencyResult.VirtualCurrency] = addUserCurrencyResult.Balance;
    var invChangeObj =
    {
      VirtualCurrency: currencyUpdated
    };
    return generateInventoryChange("MissionClaimed", invChangeObj);
}
handlers.endDaily = function(args, context) 
{
	var mC = CheckMaintenanceAndVersion(args);
  	if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  	
	var dStatus = server.GetUserInternalData(
	{
	    PlayFabId: currentPlayerId,
	    Keys: ["DailyMissionStatus"]
	});
	if(dStatus.Data.DailyMissionStatus == undefined)
	{
		return generateErrObj("No daily mission data found on server");
	}
	var parsedData = JSON.parse(dStatus.Data.DailyMissionStatus.Value);
	var DailyMissionClaimStatus = parsedData.dailyMissionClaimStatus;
  	var DailyStatus = Number(parsedData.DailyStatus);
  	var TimeRemaining = -1;
	for(var i = 0; i < parsedData.dailyMissionClaimStatus.length; i++)
	{
		if(DailyMissionClaimStatus[i] == 0) return generateErrObj("Not all missions were claimed!");
	}
  //all missions claimed so let's give the player what they are due and set the daily mission status

  	DailyMissionClaimStatus = [0,0,0,0,0,0,0,0];
	
	 var tData = server.GetTitleData(
	      {
	        PlayFabId : currentPlayerId,
	        Keys : ["DailyMissionData"]
	      }
	    );
	 var totalMinutes = 600;
	 tParsed = JSON.parse(tData.Data.DailyMissionData);
	 totalMinutes = Number(tParsed.minutesToRefresh);

  	var d = new Date();
  	var timeStamp;
	if(d.getTime() - Number(parsedData.timeStamp) > Number(totalMinutes) *60*1000) // minutes *60*1000
	{ // we need to generate a new daily mission for the user in this case
		DailyStatus = 2; //0 <- waiting for daily timer, 1 <- generate daily, 2 <- daily is ongoing
		timeStamp = d.getTime();
	}
	else
	{
		DailyStatus = 0;
		TimeRemaining = (Number(totalMinutes) *60) - (Math.floor((d.getTime() - Number(parsedData.timeStamp))/1000)); // time remaining till next quest in seconds
		timeStamp = parsedData.timeStamp;
	}

			var dailyObject = 
			{
				"DailyStatus" : DailyStatus,
				"dailyMissionClaimStatus" : DailyMissionClaimStatus,
				"timeStamp" : timeStamp
			};
			var dailyObjectStringified = JSON.stringify(dailyObject);
			var objectToUpdate = 
			{
				"DailyMissionStatus" : dailyObjectStringified
			}
			server.UpdateUserInternalData(
		       {
		          PlayFabId: currentPlayerId,
		          Data: objectToUpdate
		       });

	  var invChangeObj;
	  var userInventoryObject = server.GetUserInventory(
	    {
	      PlayFabId: currentPlayerId
	    }
	  );
	  var addUserCurrencyResult;
	  for(var p in args.currencyReq)
	  {
	    if(args.currencyReq[p] > 0)
	    addUserCurrencyResult = server.AddUserVirtualCurrency(
	      {
	        PlayFabId: currentPlayerId,
	        VirtualCurrency : p,
	        Amount: args.currencyReq[p]
	      }
	    );

	  }
	  var itemData;
	  var itemFound = false;
	  var newAmount = 0;
	  //car cards
	  for(var p in args.carCardsRequest)
	  {
	    //log.debug(p + " : " + args.carCardsRequest[p]);
	    if (args.carCardsRequest.hasOwnProperty(p))
	    {
	      itemFound = false;
	      newAmount = 0;
	      //log.debug("looking for: " +p);
	      for(var i = 0; i < userInventoryObject.Inventory.length; i++)
	      {
	        if((userInventoryObject.Inventory[i].ItemId == p) && (userInventoryObject.Inventory[i].CatalogVersion == "CarCards"))
	        {
	          // log.debug("adding amount to: " + userInventoryObject.Inventory[i].ItemInstanceId);
	          if(userInventoryObject.Inventory[i].CustomData == undefined)
	          {
	            newAmount = Number(args.carCardsRequest[p]);
	          }
	          else
	          {
	            if(userInventoryObject.Inventory[i].CustomData.Amount == undefined)
	            newAmount = Number(args.carCardsRequest[p]);
	            else
	            {
	              if(isNaN(Number(userInventoryObject.Inventory[i].CustomData.Amount)))
	              newAmount = Number(args.carCardsRequest[p]);
	              else
	              newAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + Number(args.carCardsRequest[p]);
	            }
	          }
	          itemData = {"Amount" : newAmount};
	          server.UpdateUserInventoryItemCustomData(
	            {
	              PlayFabId: currentPlayerId,
	              ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
	              Data: itemData
	            }
	          );
	          itemFound = true;
	          break;
	        }
	      }
	      if(itemFound == false)
	      {
	        var itemsToGrant = [p];
	        var grantVar = server.GrantItemsToUser(
	          {
	            CatalogVersion : "CarCards",
	            PlayFabId: currentPlayerId,
	            ItemIds : itemsToGrant
	          }
	        );

	        itemData = {"Amount" : args.carCardsRequest[p]};
	        server.UpdateUserInventoryItemCustomData(
	          {
	            PlayFabId: currentPlayerId,
	            ItemInstanceId: grantVar.ItemGrantResults[0].ItemInstanceId,
	            Data: itemData
	          }
	        );
	      }
	    }
	  }
	  //part cards
	  for(var p in args.partCardsRequest)
	  {
	    //log.debug(p + " : " + args.partCardsRequest[p]);
	    if (args.partCardsRequest.hasOwnProperty(p))
	    {
	      itemFound = false;
	      newAmount = 0;
	      // log.debug("looking for: " +p);
	      for(var i = 0; i < userInventoryObject.Inventory.length; i++)
	      {
	        if((userInventoryObject.Inventory[i].ItemId == p) && (userInventoryObject.Inventory[i].CatalogVersion == "PartCards"))
	        {
	          // log.debug("adding amount to: " + userInventoryObject.Inventory[i].ItemInstanceId);
	          if(userInventoryObject.Inventory[i].CustomData == undefined)
	          {
	            newAmount = Number(args.partCardsRequest[p]);
	          }
	          else
	          {
	            if(userInventoryObject.Inventory[i].CustomData.Amount == undefined)
	            newAmount = Number(args.partCardsRequest[p]);
	            else
	            {
	              if(isNaN(Number(userInventoryObject.Inventory[i].CustomData.Amount)))
	              newAmount = Number(args.partCardsRequest[p]);
	              else
	              newAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + Number(args.partCardsRequest[p]);
	            }
	          }
	          itemData = {"Amount" : newAmount};
	          server.UpdateUserInventoryItemCustomData(
	            {
	              PlayFabId: currentPlayerId,
	              ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
	              Data: itemData
	            }
	          );
	          itemFound = true;
	          break;
	        }
	      }
	      if(itemFound == false)
	      {
	        var itemsToGrant = [p];
	        var grantVar = server.GrantItemsToUser(
	          {
	            CatalogVersion : "PartCards",
	            PlayFabId: currentPlayerId,
	            ItemIds : itemsToGrant
	          }
	        );

	        itemData = {"Amount" : args.partCardsRequest[p]};
	        server.UpdateUserInventoryItemCustomData(
	          {
	            PlayFabId: currentPlayerId,
	            ItemInstanceId: grantVar.ItemGrantResults[0].ItemInstanceId,
	            Data: itemData
	          }
	        );
	      }
	    }
	  }

	  var outInventory = server.GetUserInventory({PlayFabId: currentPlayerId});
		var dStObj = 
		{
			status : DailyStatus,
			claimStatus : DailyMissionClaimStatus,
			timeRemaining : TimeRemaining
		};

	    var r = {
    		Result: "OK",
    		Message: "DailyCompleted",
    		InventoryChange:outInventory,
    		"DailyStatus":dStObj
  			};
  	return r;
}

handlers.endGame = function(args, context) {
  
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);

  //var wlStat = "01";
  //var wlStatInt = 0;
  //var curWL = "0";
  //if(args.outcome == "rWin")curWL="1";
  //var ps=server.GetPlayerStatistics(
  //{
//     PlayFabId: currentPlayerId,
//     StatisticNames: ["WinLoss"]
//  });
//  if(ps.Statistics.length != 0)
//  {
//      wlStatInt = ps.Statistics[0].Value.toString();
//      //log.debug("wlStatInt " + wlStatInt);
//      wlStat = Number(wlStatInt).toString(2);
//      //log.debug("wlStat " + wlStat);
//  }
//  var wins = 0;
//  var totalGames = 2;
//  var winRatio = 0;
//  //log.debug("wlStat.length " + wlStat.length);
//  var tempString = new Array(wlStat.length);
//  //log.debug("tempString.length " + tempString.length);
//  for(var i = 0 ; i < tempString.length - 1; i++)
//  {
//    tempString[i] = wlStat[i];
//  }
//	tempString[tempString.length-1] = curWL;
//  //log.debug("tempString " + tempString);
//  wlStat = tempString;
//  //log.debug("wlStat " + wlStat);
//	totalGames = wlStat.length;
//  var winStreak = 0;
//  var winStreakTemp = 0;
//	for(var i = 1; i < wlStat.length; i++)
//	{
//		if(wlStat[i] == "1") 
//      {
//        wins++;
//        winStreakTemp++;
//      }
//      else
//      {
//        if(winStreakTemp > winStreak)
//        {
//          winStreak = winStreakTemp;
//        }
//        winStreakTemp = 0;
//      }
//	}
	//log.debug("wlStatNew " + wlStat);

//  winRatio = Math.round( 100* (wins/totalGames));
  //log.debug("winRatio " + winRatio);
  //let's get some relevant title wide data
    var titleDataRequest = server.GetTitleData(
    {
      Key: ["LeagueSubdivisions","SubdivisionTrophyRanges"]
    }
    );
  //let's update user trophies
  var trophyCount = 0;
  var initTrophyCount = 0;
  var tc=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["TrophyCount"]
  });
  if(tc.Statistics.length != 0)
  {
    trophyCount = tc.Statistics[0].Value;
    if(args.debug == true) log.debug("getting trophy count " + tc.Statistics[0].Value);
  }
  trophyCount = Number(trophyCount);
  initTrophyCount = trophyCount;
  var pDat = server.GetUserInternalData(
  {
    PlayFabId: currentPlayerId,
    Keys: ["trophyLose","trophyWin"]
  });
  var refund;
  //log.debug("pDat.Data[trophyLose] " + pDat.Data["trophyLose"].Value);
  //log.debug("pDat.Data[trophyWin] " + pDat.Data["trophyWin"].Value);
  if((pDat.Data["trophyLose"] == undefined) || (pDat.Data["trophyWin"] == undefined)) refund = 45;
  else refund = Number(pDat.Data["trophyLose"].Value) + Number(pDat.Data["trophyWin"].Value);
  //log.debug("refund: " + refund);

//previous game data
  var dataToUpdate = 
  {
     "quitLastGame" : "false",
     "LastGameOutcome" : "Loss"
  }

  if(args.outcome == "rWin")
  {
  		trophyCount += refund;
      dataToUpdate["LastGameOutcome"] = "Win";
  }

  server.UpdateUserInternalData(
      {
          PlayFabId: currentPlayerId,
          Data: dataToUpdate
      });

 var recHeader = JSON.parse(args.recordingHeader);
//let's update the total wins/ total losses statistics
  var ms=server.GetPlayerStatistics( //miscelanious statistics
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["Wins", "TotalGamesCompleted","LongestWinStreak","BestDriftScore"]
  }).Statistics;
  var totalGamesCompleted = GetValueFromStatistics(ms, "TotalGamesCompleted", 0);
  totalGamesCompleted = Number(totalGamesCompleted) + 1;
  var totalWins = GetValueFromStatistics(ms, "Wins", 0);
  if(args.outcome == "rWin")
    totalWins = Number(totalWins) + 1;
  var longestStreak = GetValueFromStatistics(ms, "LongestWinStreak", 0);
//TODO Write code that calculates currentStreak and longest winStreak
  var bestScore = GetValueFromStatistics(ms, "BestDriftScore", 0);
  if(Number(recHeader.Score) > bestScore)
    bestScore = Number(recHeader.Score);
  //log.debug("trophies change: " + initTrophyCount + " => " + trophyCount);
  var cLeague = calculateLeague(trophyCount);
  //wlStatInt = 0;
  //for(var i = 0 ; i < wlStat.length; i++)
  //{
  //  if(wlStat[i] == "1")
  //    wlStatInt += Math.pow(2,i);
  //}
  //update stats on server
  var suArray = [];
  //var su = {StatisticName : "WinLoss", Version : "0", Value: wlStatInt};
  //suArray.push(su);
  var sut = {StatisticName : "TrophyCount", Version : "0", Value: trophyCount};
  suArray.push(sut);
  var sut = {StatisticName : "League", Version : "0", Value: cLeague};
  suArray.push(sut);
    var sut = {StatisticName : "Wins", Version : "0", Value: totalWins};
  suArray.push(sut);
    var sut = {StatisticName : "TotalGamesCompleted", Version : "0", Value: totalGamesCompleted};
  suArray.push(sut);
    var sut = {StatisticName : "LongestWinStreak", Version : "0", Value: longestStreak};
  suArray.push(sut);
    var sut = {StatisticName : "BestDriftScore", Version : "0", Value: bestScore};
  suArray.push(sut);
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: suArray
  }
  );
  //user ran out of time so we don't store recording
  //legacy code
  
  if(Number(recHeader.Score) <= 100)
    {
        var newPlayerStats =
        {
          "TrophyCount" : trophyCount,
          "League" : cLeague
        }
        return {Result : newPlayerStats};
    }
  //let's see which Subdivision this player is in
  var sdval = titleDataRequest.Data["SubdivisionTrophyRanges"];
  var sdvalParsed = JSON.parse(sdval);
  //log.debug("SubdivisionTrophyRanges " + sdvalParsed);
  var subDivision = 43;
  for(var i = 0; i < sdvalParsed.subdivisions.length; i++)
  {
  	if(initTrophyCount<sdvalParsed.subdivisions[i])
  	{
		subDivision = i;
		break;
  	}
  }
//log.debug("user is in subdivision " + subDivision);
	//let's save the player's recording
 var dict = [];
    dict.push({
        Key:   args.envIndex+"_"+args.courseIndex+"_RecPos",
        Value: args.recordingPos
    });
      dict.push({
            Key:  args.envIndex+"_"+args.courseIndex+"_RecRot",
        Value: args.recordingRot
    });
       dict.push({
            Key:  args.envIndex+"_"+args.courseIndex+"_RecHeader",
        Value: args.recordingHeader
    });
       //log.debug("updating user read only data ");
  var playerData = server.UpdateUserReadOnlyData(
    {
      PlayFabId: currentPlayerId,
      Data:dict
    }
  );

  //log.debug("updated user read only data for " + currentPlayerId + " " + playerData);
  var titleDataVal = server.GetTitleInternalData(
    {
      Key: "RecSubDivision"+subDivision, //i.e RecSubDivision0,
    }
    );
  var recPool = titleDataVal.Data["RecSubDivision"+subDivision];
  //log.debug("recPool: " + recPool);
  var recArray;
  var titleKeyVal;
  if(recPool == undefined)
  {
  	recArray = [];
  	var recObj =
  	{
  		"e": args.envIndex,
  		"c": args.courseIndex,
  		"uId": currentPlayerId
  	}
  	recArray.push(recObj);
  	titleKeyVal = JSON.stringify(recArray);
  	//log.debug("recArray: " + titleKeyVal);
  }
  else
  {
  	recArray = JSON.parse(recPool);
  	//log.debug("recArray: " + recArray);
  	var recObj =
  	{
  		"e": args.envIndex,
  		"c": args.courseIndex,
  		"uId": currentPlayerId
  	}
  	var uniqueKeyExists = false;
    //let's only keep 2 recordings per user per subdivision at max
    var currentOccurencesOfPlayer = 0;
    for(var i = 0; i < recArray.length; i++)
    {
      if(recArray[i].uId == currentPlayerId)
        currentOccurencesOfPlayer++;
    }
    if(currentOccurencesOfPlayer > 2) // no use letting the user spam his recordings on the same subdivision
    {
      var newPlayerStats =
      {
          "TrophyCount" : trophyCount,
          "League" : cLeague
      }
      return {Result : newPlayerStats};
    }

  	for(var i = 0; i < recArray.length; i++)
  	{
  		if((recArray[i].e == args.envIndex)&&(recArray[i].c == args.courseIndex))
  		{
			 uniqueKeyExists = true;
			 recArray[i] = recObj;
       /*
       //LEGACY WL RATIO SORT
            if(recArray.length == 1) break; //if it's the only recording there is no use to sort anymore
      if(i > 0) // if not first
      {
        if(recArray[i].wl > recArray[i-1].wl) // if bigger than left we start comparing to elements to the right
        {
          if(i == recArray.length-1) break; // there are no more elements to the right so no more sorting required
          for(var j = i + 1; j < recArray.length; j++) // we check elements i+1 to length-1
          {
            if(recArray[j - 1].wl > recArray[j].wl) // if wl of element j - 1 is greater than that of element j we swap them
            {
              var aux = recArray[j];
              recArray[j] = recArray[j - 1];
              recArray[j - 1] = aux;
            }
            else // the element stays where it is
            {
              break;
            }
          }
        }
        else // not bigger than the left let's start comparing with elements to the left
        {
          for(var j = i - 1; j >= 0; j--) // we check elements i-1 to 0
          {
            if(recArray[j + 1].wl < recArray[j].wl) // if wl of element j + 1 is smaller than that of element j we swap them
            {
              var aux = recArray[j];
              recArray[j] = recArray[j + 1];
              recArray[j + 1] = aux;
            }
            else // the element stays where it is
            {
              break;
            }
          }
        }
        } // if(i > 0)
        else
        {
          for(var j = i + 1; j < recArray.length; j++) // we check elements i+1 to length-1
          {
            if(recArray[j - 1].wl > recArray[j].wl) // if wl of element j - 1 is greater than that of element j we swap them
            {
              var aux = recArray[j];
              recArray[j] = recArray[j - 1];
              recArray[j - 1] = aux;
            }
            else // the element stays where it is
            {
              break;
            }
          }
        }
       */
  		}
  	}
  	if(uniqueKeyExists == false)
  	{
  	 // log.debug("recArrayLNbefore: " + recArray.length);
  	  recArray.push(recObj);
  	  //log.debug("recArrayLNafter: " + recArray.length);
    }
  	titleKeyVal = JSON.stringify(recArray);
  //	log.debug("titleKeyVal: " + titleKeyVal);
  }

  var titleData = server.SetTitleInternalData(
    {
      Key: "RecSubDivision"+subDivision, //Recording_0_0
      Value: titleKeyVal
    }
    );
   var newPlayerStats =
     {
          "TrophyCount" : trophyCount,
          "League" : cLeague
      };
  return {Result : newPlayerStats};
}
/**
* Updates the amount of experience the user has based on given variables
* @param {string} catalogId the ID of the catalog holding xp data
* @param {string} itemId the id of the item holding xp data from the given catalog
* @param {string} xpArrayId the id of the object holding xp data from the give item
* @param {int} actionLevel the level of the exectued action (used to get the amount of xp to give)
* @param {bool} updateServer update experience to the server
* @param {int} playerStatistics array containing player experience, if not provided a GetPlayerStatistics will be done
*/
function UpdateExperience(catalogId, itemId, xpArrayId, actionLevel, updateServer, playerStatistics)
{
  //the amount of xp gained at each action level
  var xpGainByLevel = JSON.parse(getCatalogItem(catalogId, itemId).CustomData)[xpArrayId];

  //xp cap to stop the user to level up past a given level
  var lvlThresholds = JSON.parse(getCatalogItem("Balancing", "BalancingItem").CustomData).LevelThresholds;
  var xpCap = lvlThresholds[lvlThresholds.length - 1];

  //get current exprience
  var ps= playerStatistics || server.GetPlayerStatistics({
    PlayFabId: currentPlayerId,
    StatisticNames: ["Experience"]
  }).Statistics;
  var currentExprience = GetValueFromStatistics(ps, "Experience", 0);

  if(currentExprience >= xpCap)
    return xpCap;

  var xpToReceive = 0;
  if(!isNaN(Number(xpGainByLevel))){
    //action levels are represented by a single number value, the amount to give is xpGain
    xpToReceive = Number(xpGainByLevel);
    if(xpToReceive === 0) return currentExprience;
  }
  else {
    //action levels are represented by an object
    var ln = Number(xpGainByLevel.length);
    if(actionLevel >= ln) actionLevel = ln - 1;
    xpToReceive = Number(xpGainByLevel[actionLevel]);
  }

  //cap and update player's current experience
  currentExprience = Math.min(currentExprience + xpToReceive, xpCap);

  if(!updateServer) return currentExprience;
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: [{StatisticName: "Experience", Version : "0", Value: currentExprience}]
  });
  return currentExprience;
}
handlers.generateDaily = function(args, context) 
{
	var DailyStatus = 1; //0 <- waiting for daily timer, 1 <- generate daily, 2 <- daily is ongoing
	var DailyMissionClaimStatus = [0,0,0,0,0,0,0,0];
	var d = new Date();

	var dStatus = server.GetUserInternalData(
	{
	    PlayFabId: currentPlayerId,
	    Keys: ["DailyMissionStatus"]
	});

	if(dStatus.Data.DailyMissionStatus != undefined)
	{
	    var parsedData = JSON.parse(dStatus.Data.DailyMissionStatus.Value);
		DailyStatus = Number(parsedData.DailyStatus);

		if(DailyStatus == 0) // we only check if status should be 1 from status 0
		{
	      var tData = server.GetTitleData(
	        {
	          PlayFabId : currentPlayerId,
	          Keys : ["DailyMissionData"]
	        }
	      );
	      var totalMinutes = 600;
	      tParsed = JSON.parse(tData.Data.DailyMissionData);
	      totalMinutes = Number(tParsed.minutesToRefresh);

	      var d = new Date();
	      if(d.getTime() - Number(parsedData.timeStamp) > Number(totalMinutes) *60*1000) // minutes *60*1000
	      {
	      	DailyStatus = 1; // time's up we have to tell the client that it is time to generate a new daily
	      }
	  	}

		if(DailyStatus != 1)
			return generateErrObj("DailyStatus is: " + DailyStatus + ". Should be 1");
	}

	DailyStatus = 2; //we are now in ongoing mode
	var timeStamp = d.getTime();
	var dailyObject = 
	{
		"DailyStatus" : DailyStatus,
		"dailyMissionClaimStatus" : DailyMissionClaimStatus,
		"timeStamp" : timeStamp
	};
	var dailyObjectStringified = JSON.stringify(dailyObject);
	var objectToUpdate = 
	{
		"DailyMissionStatus" : dailyObjectStringified
	}
	server.UpdateUserInternalData(
       {
          PlayFabId: currentPlayerId,
          Data: objectToUpdate
       });

	var r = 
	{
    	"Result": "OK"
  	};
  	return r;
}
handlers.getDailyMissionStatus = function(args, context) {

  	//var mC = CheckMaintenanceAndVersion(args);
  	//if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  	var mC = CheckMaintenanceAndVersion(args);
  	if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  	
	var DailyStatus = 2; //0 <- waiting for daily timer, 1 <- generate daily, 2 <- daily is ongoing
	var DailyMissionClaimStatus = [0,0,0,0,0,0,0,0];
	var TimeRemaining = -1;
	var dStatus = server.GetUserInternalData(
	{
	    PlayFabId: currentPlayerId,
	    Keys: ["DailyMissionStatus"]
	});

	if(dStatus.Data.DailyMissionStatus != undefined)
	{
		var parsedData = JSON.parse(dStatus.Data.DailyMissionStatus.Value);
		DailyStatus = Number(parsedData.DailyStatus);	
		var tempLength = DailyMissionClaimStatus.length;
		if(tempLength > parsedData.dailyMissionClaimStatus.length) tempLength = parsedData.dailyMissionClaimStatus.length;
		for(var i = 0; i < tempLength; i++)
		{
			DailyMissionClaimStatus[i] = parsedData.dailyMissionClaimStatus[i];
		}

		if(DailyStatus == 0) // we only return remaining time till next quest if status is waiting for daily timer
		{
	      var tData = server.GetTitleData(
	        {
	          PlayFabId : currentPlayerId,
	          Keys : ["DailyMissionData"]
	        }
	      );
	      var totalMinutes = 600;
	      tParsed = JSON.parse(tData.Data.DailyMissionData);
	      totalMinutes = Number(tParsed.minutesToRefresh);

	      var d = new Date();
	      if(d.getTime() - Number(parsedData.timeStamp) > Number(totalMinutes) *60*1000) // minutes *60*1000
	      {
	      	DailyStatus = 2; // time's up we have to  generate a new daily
	      	DailyMissionClaimStatus = [0,0,0,0,0,0,0,0];
	      	var timeStamp = d.getTime();

			var dailyObject = 
			{
				"DailyStatus" : DailyStatus,
				"dailyMissionClaimStatus" : DailyMissionClaimStatus,
				"timeStamp" : timeStamp
			};
			var dailyObjectStringified = JSON.stringify(dailyObject);
			var objectToUpdate = 
			{
				"DailyMissionStatus" : dailyObjectStringified
			}
			server.UpdateUserInternalData(
		       {
		          PlayFabId: currentPlayerId,
		          Data: objectToUpdate
		       });
	      }
	      else
	      {
	      	TimeRemaining = (Number(totalMinutes) *60) - (Math.floor((d.getTime() - Number(parsedData.timeStamp))/1000)); // time remaining till next quest in seconds
	      }
		}
	}
	else
	{
		DailyStatus = 2; //we are now in ongoing mode
		var d = new Date();
		var timeStamp = d.getTime();
		var dailyObject = 
		{
			"DailyStatus" : DailyStatus,
			"dailyMissionClaimStatus" : DailyMissionClaimStatus,
			"timeStamp" : timeStamp
		};
		var dailyObjectStringified = JSON.stringify(dailyObject);
		var objectToUpdate = 
		{
			"DailyMissionStatus" : dailyObjectStringified
		}
		server.UpdateUserInternalData(
	       {
	          PlayFabId: currentPlayerId,
	          Data: objectToUpdate
	       });
	}
	var dStObj = 
	{
		status : DailyStatus,
		claimStatus : DailyMissionClaimStatus,
		timeRemaining : TimeRemaining
	};
	var r = 
	{
    	"Result": "OK",
    	"Message": " ",
    	"DailyStatus":dStObj
  	};
  	return r;
}
handlers.getServerTime = function(args, context)
{
	var t = new Date();
	return { time: t};
}
handlers.iapMade = function(args, context)
{
	//this code will fire whenever a IAP is succesfully validated
}
handlers.initServerData = function(args)
{
//create trophy statistic
var suArray = [];

var su = {StatisticName : "TrophyCount", Version : "0", Value: "0"};
suArray.push(su);
su = {StatisticName : "League", Version : "0", Value: "0"};
suArray.push(su);

var updateRequest = server.UpdatePlayerStatistics(
{
  PlayFabId: currentPlayerId,
  Statistics: suArray
}
);
var itemsToGive = ["Decals","PaintJobs", "Plates", "Rims", "WindshieldText"];
//itemsToGive.push("Decals");
//itemsToGive.push("PaintJobs");
//itemsToGive.push("Plates");
//itemsToGive.push("Rims");
//itemsToGive.push("WindshieldText");

var grantRequest = server.GrantItemsToUser(
  {
    CatalogVersion : "Customization",
    PlayFabId: currentPlayerId,
    ItemIds : itemsToGive
  }
  );

var InvData = {"0" : "Owned"};

for(var i = 0; i < grantRequest.ItemGrantResults.length; i++)
{
  server.UpdateUserInventoryItemCustomData(
       {
         PlayFabId: currentPlayerId,
         ItemInstanceId: grantRequest.ItemGrantResults[i].ItemInstanceId,
         Data: InvData
       }
       );
}
var carsToGive = [];
carsToGive.push("FordFocus");
var carRequest = server.GrantItemsToUser(
{
  CatalogVersion : "CarsProgress",
  PlayFabId: currentPlayerId,
  ItemIds : carsToGive
}
);
var CarData = {"CarLvl" : "1","EngineLvl" : "0","ExhaustLvl" : "0","GearboxLvl" : "0","SuspensionLvl" : "0"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
  Data: CarData
}
);
CarData = {"TiresLvl" : "0","TurboLvl" : "0","PaintId" : "0","DecalId" : "0","RimsId" : "0"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
  Data: CarData
}
);
CarData = {"PlatesId" : "0","WindshieldId" : "0","Pr" : "10"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
  Data: CarData
}
);

var partsToGive = [];
partsToGive.push("Engine");
var partRequest = server.GrantItemsToUser(
{
  CatalogVersion : "PartCards",
  PlayFabId: currentPlayerId,
  ItemIds : partsToGive
}
);
var PartData = {"Amount" : "5"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: partRequest.ItemGrantResults[0].ItemInstanceId,
  Data: PartData
}
);
CarData = {"CarLvl" : "1","EngineLvl" : "0","ExhaustLvl" : "0","GearboxLvl" : "0","SuspensionLvl" : "0"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
  Data: CarData
});
};
handlers.openChest = function(args, context)
{
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  
  //level reward mechanic
  //args.level == -1 if it's regular open chest operation
  //args.level >= 0 if it's a reward for leveing up to level args.level
  if(args.levelUpRewardIndex > 0)
  {
  	var lastLvlReward = 0;
    var lastRewardLevel = server.GetUserReadOnlyData(
    {
      PlayFabId : currentPlayerId,
      Keys : ["LastLevelReward"]
    });
    var levelItemDataToUpdate = {};
    levelItemDataToUpdate["LastLevelReward"] = 0;
    if(lastRewardLevel.Data.LastLevelReward == undefined)
    {
      server.UpdateUserReadOnlyData(
      {
        PlayFabId : currentPlayerId, 
        Data : levelItemDataToUpdate
      }
        );      
    }
    else
    {
    	lastLvlReward = lastRewardLevel.Data.LastLevelReward.Value;
    }
    // now let's see if the user gets a reward
      var lvlThresholds = JSON.parse(getCatalogItem("Balancing", "BalancingItem").CustomData).LevelThresholds;
        //get current exprience
      var ps= server.GetPlayerStatistics(
      {
            PlayFabId: currentPlayerId,
            StatisticNames: ["Experience"]
      }).Statistics;
      var currentExprience = GetValueFromStatistics(ps, "Experience", 0);
      if(currentExprience == 0) // this most likely means that the user doesn't have the exp statistic so let's give it to them
      {
      	  var suArray = [];
	      var su = {StatisticName : "Experience", Version : "0", Value: 0};
	      suArray.push(su);

	      server.UpdatePlayerStatistics(
	      {
	        PlayFabId : currentPlayerId,
	        Statistics: suArray
	      });
      }
      var currLvl = lvlThresholds.length;
      for(var i = 0; i < lvlThresholds.length; i++)
      {
        if(currentExprience >= lvlThresholds[i]) continue;
        currLvl = i; break;
      }

      if(Number(args.levelUpRewardIndex) <= Number(currLvl))
      {
        lastLvlReward = Number(args.levelUpRewardIndex);
        levelItemDataToUpdate["LastLevelReward"] = lastLvlReward;
        server.UpdateUserReadOnlyData(
        {
          PlayFabId : currentPlayerId, 
          Data : levelItemDataToUpdate
        }
          );
        //give bundle to user
        //ids of bundles are of the form 001, 002, ... , 012 etc so padded with 0s until it has 3 digits
        var str = "" + lastLvlReward;
        var pad = "000";
        var ans = pad.substring(0, pad.length - str.length) + str; 
        server.GrantItemsToUser(
        {
          CatalogVersion : "LevelUpRewards",
          PlayFabId : currentPlayerId, 
          ItemIds : ans
        }
          );      
        }
        else return generateFailObj("already got reward for level: " + lastLvlReward);

  }
  var objectsUpdated = [];
  var currencyUpdated = [];
  var invChangeObj;
  var userInventoryObject = server.GetUserInventory(
    {
      PlayFabId: currentPlayerId
    }
  );

  //let's check if this is a chest from the store
  if(args.currCost > 0)
  {
    var bO = checkBalance(args.currType, args.currCost, userInventoryObject.VirtualCurrency["SC"], userInventoryObject.VirtualCurrency["HC"])
    if(bO != "OK") return generateFailObj("not enough money");

    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : args.currType,
        Amount: args.currCost
      }
    );
    updateCurrencySpentStatistic(args.currType, args.currCost);
  }
  //currency
  var addUserCurrencyResult;
  for(var p in args.currencyReq)
  {
    if(args.currencyReq[p] > 0)
    addUserCurrencyResult = server.AddUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : p,
        Amount: args.currencyReq[p]
      }
    );

  }
  var itemData;
  var itemFound = false;
  var newAmount = 0;
  //car cards
  for(var p in args.carCardsRequest)
  {
    //log.debug(p + " : " + args.carCardsRequest[p]);
    if (args.carCardsRequest.hasOwnProperty(p))
    {
      itemFound = false;
      newAmount = 0;
      //log.debug("looking for: " +p);
      for(var i = 0; i < userInventoryObject.Inventory.length; i++)
      {
        if((userInventoryObject.Inventory[i].ItemId == p) && (userInventoryObject.Inventory[i].CatalogVersion == "CarCards"))
        {
          // log.debug("adding amount to: " + userInventoryObject.Inventory[i].ItemInstanceId);
          if(userInventoryObject.Inventory[i].CustomData == undefined)
          {
            newAmount = Number(args.carCardsRequest[p]);
          }
          else
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount == undefined)
            newAmount = Number(args.carCardsRequest[p]);
            else
            {
              if(isNaN(Number(userInventoryObject.Inventory[i].CustomData.Amount)))
              newAmount = Number(args.carCardsRequest[p]);
              else
              newAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + Number(args.carCardsRequest[p]);
            }
          }
          itemData = {"Amount" : newAmount};
          server.UpdateUserInventoryItemCustomData(
            {
              PlayFabId: currentPlayerId,
              ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
              Data: itemData
            }
          );
          itemFound = true;
          break;
        }
      }
      if(itemFound == false)
      {
        var itemsToGrant = [p];
        var grantVar = server.GrantItemsToUser(
          {
            CatalogVersion : "CarCards",
            PlayFabId: currentPlayerId,
            ItemIds : itemsToGrant
          }
        );

        itemData = {"Amount" : args.carCardsRequest[p]};
        server.UpdateUserInventoryItemCustomData(
          {
            PlayFabId: currentPlayerId,
            ItemInstanceId: grantVar.ItemGrantResults[0].ItemInstanceId,
            Data: itemData
          }
        );
      }
    }
  }
  //part cards
  for(var p in args.partCardsRequest)
  {
    //log.debug(p + " : " + args.partCardsRequest[p]);
    if (args.partCardsRequest.hasOwnProperty(p))
    {
      itemFound = false;
      newAmount = 0;
      // log.debug("looking for: " +p);
      for(var i = 0; i < userInventoryObject.Inventory.length; i++)
      {
        if((userInventoryObject.Inventory[i].ItemId == p) && (userInventoryObject.Inventory[i].CatalogVersion == "PartCards"))
        {
          // log.debug("adding amount to: " + userInventoryObject.Inventory[i].ItemInstanceId);
          if(userInventoryObject.Inventory[i].CustomData == undefined)
          {
            newAmount = Number(args.partCardsRequest[p]);
          }
          else
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount == undefined)
            newAmount = Number(args.partCardsRequest[p]);
            else
            {
              if(isNaN(Number(userInventoryObject.Inventory[i].CustomData.Amount)))
              newAmount = Number(args.partCardsRequest[p]);
              else
              newAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + Number(args.partCardsRequest[p]);
            }
          }
          itemData = {"Amount" : newAmount};
          server.UpdateUserInventoryItemCustomData(
            {
              PlayFabId: currentPlayerId,
              ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
              Data: itemData
            }
          );
          itemFound = true;
          break;
        }
      }
      if(itemFound == false)
      {
        var itemsToGrant = [p];
        var grantVar = server.GrantItemsToUser(
          {
            CatalogVersion : "PartCards",
            PlayFabId: currentPlayerId,
            ItemIds : itemsToGrant
          }
        );

        itemData = {"Amount" : args.partCardsRequest[p]};
        server.UpdateUserInventoryItemCustomData(
          {
            PlayFabId: currentPlayerId,
            ItemInstanceId: grantVar.ItemGrantResults[0].ItemInstanceId,
            Data: itemData
          }
        );
      }
    }
  }

  var outInventory =   server.GetUserInventory({PlayFabId: currentPlayerId});

  //give experience for opening chest unless this chest was opened as part of leveling up reward:
  //if no chest id is provided, it means that this function is used for inventory update
  if((args.chestId) && (args.levelUpRewardIndex <= 0)){
    var totalXp = UpdateExperience("Chests", args.chestId, "xpGain", 0, true);
      outInventory.Experience = totalXp;
  }

  return generateInventoryChange("InventoryUpdated", outInventory);
};
handlers.purchaseBMItem = function(args, context)
{
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  
  //log.debug("purchasing item " + args.itemId + " from black market");
  if((args.itemId < 0) || (args.itemId > 3)) return generateFailObj("invalid item index");
  var keysToGet = [];
  keysToGet.push("BMItem" + args.itemId);

  var getInternalDataResult = server.GetUserInternalData(
  {
    PlayFabId: currentPlayerId,
    Keys: keysToGet
  }
  );

  var userInventoryObject = server.GetUserInventory(
  {
    PlayFabId: currentPlayerId
  }
  );

  var userArray = getInternalDataResult.Data["BMItem" + args.itemId].Value.split("_");//name, curr, baseCost, uses, costUse
  //log.debug("userArray: " + userArray);
  var playerMoney = userInventoryObject.VirtualCurrency[userArray[1]];

  if(userArray.length != 5)
  {
    generateErrObj("User Black Market corrupted. Try again tomorrow");
  }

  var catalogName = "";
  if(args.itemId < 2)
    catalogName = "PartCards";
  else
    catalogName = "CarCards";

  var price = parseInt(userArray[2]) + parseInt(userArray[3])* parseInt(userArray[4]);
  var checkObj = checkBalance(userArray[1], price, playerMoney, playerMoney);
  if(checkObj != "OK") return checkObj;
  //try
  //{
    var cardInstance;
    var cardAmount = 0;
    var cardData;
   // log.debug("searching for: " + userArray[0] + " in " + catalogName);
    for(var i = 0; i < userInventoryObject.Inventory.length; i++) // if we find it in the inventory we just give him the amount of cards we owe the player
    {
      if((userInventoryObject.Inventory[i].ItemId == userArray[0]) && (userInventoryObject.Inventory[i].CatalogVersion == catalogName))
      {
       // log.debug("found it!");
        cardInstance = userInventoryObject.Inventory[i].ItemInstanceId;
        if(userInventoryObject.Inventory[i].CustomData === undefined)
        {
         // log.debug("no custom data. creating ...");
          cardData = {"Amount" : 1};
        }
        else
        {
          if(userInventoryObject.Inventory[i].CustomData.Amount === undefined)
            cardData = {"Amount" : 1};
          else
          {
          var tempAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + 1;
          if(isNaN(tempAmount)) tempAmount = 1;
          cardData = {"Amount" : tempAmount};
          }
        }

        server.UpdateUserInventoryItemCustomData(
              {
                PlayFabId: currentPlayerId,
                ItemInstanceId: cardInstance,
                Data: cardData
              }
              );

        break;
      }
    }
    if(cardInstance === undefined)
    {
      //log.debug("cardInstance is undefined");
      var itemsToGive = [];
      itemsToGive.push(userArray[0]);
      var grantRequest = server.GrantItemsToUser(
        {
          CatalogVersion : catalogName,
          PlayFabId: currentPlayerId,
          ItemIds : itemsToGive
        }
        );
      cardInstance = grantRequest.ItemGrantResults[0].ItemInstanceId;
      if(cardInstance === undefined)
        generateErrObj("grantRequest denied");
      else
      {
        cardData = {"Amount" : 1};
        server.UpdateUserInventoryItemCustomData(
          {
            PlayFabId: currentPlayerId,
            ItemInstanceId: cardInstance,
            Data: cardData
          }
          );
      }
    }
    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : userArray[1],
        Amount: price
      }
      );
    updateCurrencySpentStatistic(userArray[1], price);
    var itemVal = userArray[0] + "_" + userArray[1] + "_" + userArray[2] + "_"  + (parseInt(userArray[3]) + 1) + "_" +  userArray[4];
    //log.debug("generatedArray: " + itemVal);
    var dataToUpdate = {};
    dataToUpdate["BMItem" + args.itemId] = itemVal;
    server.UpdateUserInternalData(
      {
        PlayFabId : currentPlayerId,
        Data : dataToUpdate
      }  );
    var objectsUpdated =
        [
        {
          ItemId : userArray[0],
          CatalogVersion: catalogName,
          CustomData: cardData
        }
        ];

      var currencyUpdated = {};
      currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
      var b=args.itemId+"_"+userArray[2]+"_"+(parseInt(userArray[3]) + 1)+"_"+userArray[4];
      i={
            Inventory: objectsUpdated,
            VirtualCurrency: currencyUpdated
        };
      var returnObj = {
        Result: "OK",
        Message: "InventoryUpdate",
        InventoryChange:i,
        BMItemChange: b
      };
      return returnObj;
};
handlers.purchaseItems = function(args, context)
{
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  //retrieve user inventory
  //log.debug("RETRIEVING USER INVENTORY");
  var userInventoryObject = server.GetUserInventory(
    {
      PlayFabId: currentPlayerId
    }
  );
  //retrieve player currency
  var playerSC = userInventoryObject.VirtualCurrency.SC;
  var playerHC = userInventoryObject.VirtualCurrency.HC;

  //log.debug("user currency: SC: " + playerSC + " HC: " + playerHC);

  switch(args.purchaseType)
  {
    case "carUpgrade":
      return upgradeCar(args, userInventoryObject, playerSC, playerHC);

    case "partUpgrade":
      return upgradePart(args, userInventoryObject, playerSC, playerHC);

    case "custPurchase":
    // log.debug("Purchasing Customization: " + args.custId + " with val: " + args.custVal);
    var custCatalog = server.GetCatalogItems(
      {
        CatalogVersion : "Customization"
      }
    );

    var custCatalogItem;
    var custPrice = 0;
    var custCurr = "SC";
    for(var i = 0; i < custCatalog.Catalog.length; i++)
    {
      if(custCatalog.Catalog[i].ItemId == args.custId)
      {
        custCatalogItem = custCatalog.Catalog[i];
        cardInfo = JSON.parse(custCatalog.Catalog[i].CustomData)
        var keyRequestCurr = args.custVal + ",Curr";
        var keyRequestCost = args.custVal + ",Cost";

        custCurr = cardInfo[keyRequestCurr];
        custPrice = cardInfo[keyRequestCost];

        var costCheckObj = checkBalance(custCurr, custPrice, playerSC, playerHC);
        if(costCheckObj != "OK") return costCheckObj;

        // log.debug("custCurr: " + custCurr);
        //   log.debug("custPrice: " + custPrice);

        break;
      }
    }

    if(custCatalogItem == undefined)
    return generateErrObj("Customization does not exist in catalog.");

    //  log.debug("Checking to see if user has said customization");
    var customizationItem;
    var customizationItemInstance;
    for(var i = 0; i < userInventoryObject.Inventory.length; i++)
    {
      if(userInventoryObject.Inventory[i].ItemId == args.custId)
      {
        //       log.debug("user has customization category!");
        customizationItem = userInventoryObject.Inventory[i];
        customizationItemInstance = userInventoryObject.Inventory[i].ItemInstanceId;
        if (customizationItem.CustomData != undefined)
        {
          if (String(args.custVal) in customizationItem.CustomData)
          {
            return generateFailObj("User already has this customization.");
          }
        }
        break;
      }
    }

    if(customizationItem == undefined)
    {
      log.info("user doesn't have customization category. Granting ... ");
      var itemsToGive = [];
      itemsToGive.push(args.custId);

      var custToGive = server.GrantItemsToUser(
        {
          CatalogVersion : "Customization",
          PlayFabId: currentPlayerId,
          ItemIds : itemsToGive
        }
      );

      if(custToGive.ItemGrantResults[0].Result == false)
      return generateErrObj("something went wrong while granting user customization class object.");

      customizationItemInstance = custToGive.ItemGrantResults[0].ItemInstanceId;
    }

    var customizationData = {};
    customizationData[String(args.custVal)] = "Owned";

    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: customizationItemInstance,
        Data: customizationData
      }
    );
    var i;
    var objectsUpdated =
    [
      {
        ItemId : args.custId,
        CatalogVersion: "Customization",
        CustomData : customizationData
      }
    ];

    if(custPrice > 0)
    {
      var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
        {
          PlayFabId: currentPlayerId,
          VirtualCurrency : custCurr,
          Amount: custPrice
        }
      );
      updateCurrencySpentStatistic(custCurr, custPrice);
      var currencyUpdated = {};
      currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
      i =
      {
        Inventory: objectsUpdated,
        VirtualCurrency: currencyUpdated
      };
    }
    else
    {
      i =
      {
        Inventory: objectsUpdated
      };
    }
    return generateInventoryChange("InventoryUpdateNewCustomization", i)

    break; // big switch
    case "softCurrencyPurchase":
    //   log.debug("Purchasing pack: " + args.packId);

    //   log.debug("Checking to see if pack exists in catalog");
    var packCatalog = server.GetCatalogItems(
      {
        CatalogVersion : "SoftCurrencyStore"
      }
    );

    var packExists = false;
    var packPrice = 0;
    for(var i = 0; i < packCatalog.Catalog.length; i++)
    {
      if(packCatalog.Catalog[i].ItemId == args.packId)
      {
        packPrice = packCatalog.Catalog[i].VirtualCurrencyPrices.HC;
        cardInfo = JSON.parse(packCatalog.Catalog[i].CustomData);
        packExists = true;
        break;
      }
    }

    if(packExists == false)
    return generateErrObj("pack with ID: " + args.packId + " not found in catalog.");

    if(packPrice <= 0)
    return generateErrObj("pack with ID: " + args.packId + " shouldn't have negative cost.");

    if(packPrice > playerHC)
    return generateFailObj("Not enough HC.");

    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : "HC",
        Amount: packPrice
      }
    );
    updateCurrencySpentStatistic("HC", packPrice);
    var addUserCurrencyResult = server.AddUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : "SC",
        Amount: cardInfo.quantity
      }
    );
    var currencyUpdated = {};
    currencyUpdated[addUserCurrencyResult.VirtualCurrency] = addUserCurrencyResult.Balance;
    currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
    var invChangeObj =
    {
      VirtualCurrency: currencyUpdated
    };
    return generateInventoryChange("SoftCurrencyPurchased", invChangeObj)
    break;

    default:
    log.debug("invalid purchase parameter");
  }
};
handlers.requestCurrency = function(args)
{
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  var userInventoryObject = server.GetUserInventory(
  {
    PlayFabId: currentPlayerId,
  }
  );
  var r =
  {
    VirtualCurrency: userInventoryObject.VirtualCurrency
  };
  return r;
};
handlers.requestInventory = function(args)
{
  //var mC = CheckMaintenanceAndVersion(args);
  //if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  var userInventoryObject = server.GetUserInventory(
  {
    PlayFabId: currentPlayerId,
  }
  );
  //let's update the user's current currency statistics
  var sc = Number(userInventoryObject.VirtualCurrency.SC);
  if(isNaN(sc) || sc < 0) sc = 0;

  var hc = Number(userInventoryObject.VirtualCurrency.HC);
  if(isNaN(hc) || hc < 0) hc = 0;

  var suArray = [];
  var sum = {StatisticName: "CurrentMoney", Version : "0", Value: sc};
  suArray.push(sum);
  var sug = {StatisticName: "CurrentGold", Version : "0", Value: hc};
  suArray.push(sug);
   var updateRequest = server.UpdatePlayerStatistics(
      {
         PlayFabId: currentPlayerId,
         Statistics: suArray
      }
      );
  //get catalog data for pr calculation
    var carCardsCatalog = server.GetCatalogItems(
         {
           CatalogVersion : "CarCards"
         }
         );
    var partCardsCatalog = server.GetCatalogItems(
       {
         CatalogVersion : "PartCards"
       }
       );
  var hasCars = false;
  for(var i = 0; i < userInventoryObject.Inventory.length; i++)
  {
    if(userInventoryObject.Inventory[i].CatalogVersion == "CarsProgress")
    {
      hasCars = true;
      var check = checkCarDataValidity(userInventoryObject.Inventory[i], carCardsCatalog);
      //log.debug("check " + check);
      if((check == "PlayFabError") || (check === undefined)) return generateErrObj("PlayfabError");
      else if(check == "OK") log.debug("Data for " + userInventoryObject.Inventory[i].ItemId + " OK");
           else userInventoryObject.Inventory[i].CustomData = check;
      userInventoryObject.Inventory[i].CustomData.Pr = recalculateCarPr(userInventoryObject.Inventory[i].CustomData, userInventoryObject.Inventory[i].ItemId, carCardsCatalog, partCardsCatalog);
      var d = {};
      d["Pr"] = userInventoryObject.Inventory[i].CustomData.Pr;
      server.UpdateUserInventoryItemCustomData( // if this doesn't happen it's still fine; we might actually be able to skip this entirely
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
        Data: d
      }
      );
    }
  }
  if(hasCars === false)
    {
      var carsToGive = [];
      carsToGive.push("FordFocus");
      var carRequest = server.GrantItemsToUser(
      {
        CatalogVersion : "CarsProgress",
        PlayFabId: currentPlayerId,
        ItemIds : carsToGive
      }
      );
      var CarData = {"CarLvl" : "1","EngineLvl" : "0","ExhaustLvl" : "0","GearboxLvl" : "0","SuspensionLvl" : "0"};
      server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
      );
      CarData = {"TiresLvl" : "0","TurboLvl" : "0","PaintId" : "0","DecalId" : "0","RimsId" : "0"};
      server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
      );
      CarData = {"PlatesId" : "0","WindshieldId" : "0","Pr" : "10"};
      server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
      );
      return generateErrObj("UserHasNoCars ... reiniting");
    }
  return userInventoryObject;
};
handlers.retrieveBlackMarket = function(args, context)
{
	var mC = CheckMaintenanceAndVersion(args);
	if(args.reset === true)
	{ 		
  		if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
	}

  //let's get last BM Time Call
  var keysToGet = [];
  keysToGet.push("BMTime");
  for(var i = 0; i < 4; i++)
  {
    keysToGet.push("BMItem" + i);
  }

  var getInternalDataResult = server.GetUserInternalData(
    {
      PlayFabId: currentPlayerId,
      Keys: keysToGet
    }
    );

  if(getInternalDataResult.Data.BMTime === undefined)
  {
    //log.debug("No user BM data detected; generating ...");
    return GenerateBlackMarket(currentPlayerId);
  }

  var d = new Date();
  //log.debug("milliseconds passed: " +  d.getTime());
  //log.debug("BMTime: " +  getInternalDataResult.Data.BMTime.Value);

  var tK = [];
  tK.push("BlackMarketResetMinutes");
  var tData = server.GetTitleData(
    {
      PlayFabId : currentPlayerId,
      Keys : tK
    }
    );
  if(args.reset === true)
  {
    //log.debug("reseting market");
    var curr = "HC";
    var cost = 200;
    var td = server.GetTitleData(
    {
      Keys : ["BlackMarketResetCost"]
    });
    if(td.Data["BlackMarketResetCost"] !== undefined)
    {
      var tDatArr = td.Data["BlackMarketResetCost"].split("_");
      curr = tDatArr[0];
      cost = Number(tDatArr[1]);
    }

    if(cost > 0)
    {
      var userInventoryObject = server.GetUserInventory(
      {
        PlayFabId: currentPlayerId
      }
      );

      var bO = checkBalance(curr, cost, userInventoryObject.VirtualCurrency.SC, userInventoryObject.VirtualCurrency.HC);
      if(bO != "OK") return generateFailObj("not enough money");

      var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
        {
          PlayFabId: currentPlayerId,
          VirtualCurrency : curr,
          Amount: cost
        }
        );
      updateCurrencySpentStatistic(curr, cost);
      var marketObject = GenerateBlackMarket(currentPlayerId);
      ////////////////
      var currencyUpdated = {};
      currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
      i =
         {
           VirtualCurrency: currencyUpdated
         };
      marketObject["InventoryChange"] = i;
      return marketObject;
      ////////////////
    }
    return GenerateBlackMarket(currentPlayerId);
  }

  if(d.getTime() - parseInt(getInternalDataResult.Data.BMTime.Value) > parseInt(tData.Data.BlackMarketResetMinutes) *60*1000) // minutes *60*1000
  {
    //log.debug("regenerating market");
    if(mC != "OK") GetCurrentBlackMarket(currentPlayerId, getInternalDataResult);
    return GenerateBlackMarket(currentPlayerId);
  }
  //log.debug("get current market");
  return GetCurrentBlackMarket(currentPlayerId, getInternalDataResult);
};
handlers.rewardUsers = function(args, context) 
{
    var ps = server.GetPlayerStatistics({
      PlayFabId: currentPlayerId,
      StatisticNames: ["Experience","TrophyCount"]
    }).Statistics;
  var currentExprience = GetValueFromStatistics(ps, "Experience", 0); // 0 - 80000
  var currentTrophies = GetValueFromStatistics(ps, "TrophyCount", 0); // 0 - 3000

  var trophyDiff = 0;
  var expToGive = 0;
  if(currentExprience <= 0) 
  {
    trophyDiff = (Number(currentTrophies) / 3000);
    expToGive = Number(Math.floor(trophyDiff * 800));
  }
  currentExprience = Number(currentExprience) + expToGive;

  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: [{StatisticName: "Experience", Version : "0", Value: currentExprience}]
  });
  return currentExprience;
}

handlers.startGame = function(args, context) {
  //let's see what subleague we are in and what win/loss ration we have
  //wlratio
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  //var wlStat = "10"; // 50/50 for newtimers
  //var wlStatInt = 0; // we change the bitwise representation to int32 and store it like that
  //var winRatio = 50;
  //var totalGames = 2;
  //var wins = 0;
  //vvar ps=server.GetPlayerStatistics(
  //{
  //   PlayFabId: currentPlayerId,
  //   StatisticNames: ["WinLoss"]
  //});
  //if(ps.Statistics.length != 0)
  //{
  //    wlStatInt = ps.Statistics[0].Value.toString();
  //    wlStat = Number(wlStatInt).toString(2);
  //    totalGames = wlStat.length;
  //    for(var i = 1; i < wlStat.length; i++)
  //    {
  //      if(wlStat[i] == "1") wins++;
  //    }
  //    winRatio = Math.round( 100* (wins/totalGames));
  //}
  //start game so we assume it'sa lose until it's a win
  //wlStat += "0";
  //log.debug("wlStatBeforeshift " + wlStat);
   //if(wlStat.length > 20)
   //{
   // var tempS = new Array(20);
   // wlStat = wlStat.slice(2);
  //  tempS[0] = "1";
   // for(var i = 0; i < wlStat.length; i++)
   // {
  //    tempS[i + 1] = wlStat[i];
   // }
  //  wlStat = tempS;
  // }
  // log.debug("wlStat " + wlStat);
  //trophy count and subleague distribution
  var leagueTitleDataRequest = server.GetTitleData(
    {
      Key: ["LeagueSubdivisions","SubdivisionTrophyRanges","TrophyGainRange","TrophyLoseRange","SubdivisionPrRanges", "TrophyDifferenceLimit"]
    }
    );
  //let's get the GamesStarted statistic
  var gss=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["TotalGames"]
  }).Statistics;
  var totalGamesStarted = GetValueFromStatistics(gss, "TotalGames", 0);
  totalGamesStarted = Number(totalGamesStarted) + 1;
  if(args.debug == true) log.debug("totalGamesStartedIs: " + totalGamesStarted);
  var tc=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["TrophyCount"]
  });
  var trophyCount = 0;
  if(tc.Statistics.length != 0)
  {
    trophyCount = tc.Statistics[0].Value;
  }
  trophyCount = Number(trophyCount);
  var sdval = leagueTitleDataRequest.Data["SubdivisionTrophyRanges"];
  var sdvalParsed = JSON.parse(sdval);
  var lsVal = leagueTitleDataRequest.Data["LeagueSubdivisions"];
  var lsValParsed = JSON.parse(lsVal);
  var sdprVal = leagueTitleDataRequest.Data["SubdivisionPrRanges"];
  var sdprValParsed = JSON.parse(sdprVal);

  //trophyAdjustment data
  var tdlVal = leagueTitleDataRequest.Data["TrophyDifferenceLimit"]; //u are here
  var tdlValParsed = JSON.parse(tdlVal);
  var trophyReadjustRange = Number(tdlValParsed.trophyReadjustRange);
  var trophyMaxDifference = Number(tdlValParsed.maxDifference);
  var excludedSubdivisionsFromTrophyAdjustment = tdlValParsed.subDivisionsToExclude;
  //log.debug("SubdivisionTrophyRanges " + sdvalParsed);
  var subDivision = 43;
  var nextSubDivision = 43;
  var subDivisionRange = 200;
          var rminmaxarr = leagueTitleDataRequest.Data["TrophyGainRange"].split("_");
          var lminmaxarr = leagueTitleDataRequest.Data["TrophyLoseRange"].split("_");
          var rMin = Number(rminmaxarr[0]);
          var rMax = Number(rminmaxarr[1]);
          var lMin = Number(lminmaxarr[0]);
          var lMax = Number(lminmaxarr[1]);
  for(var i = 0; i < sdvalParsed.subdivisions.length; i++)
  {
    if(trophyCount<Number(sdvalParsed.subdivisions[i]))
    {
      subDivision = i;
      if(i < sdvalParsed.subdivisions.length - 1) nextSubDivision = i + 1;
      break;
    }
  }
  subDivisionRange = Number(sdvalParsed.subdivisions[nextSubDivision]) - Number(sdvalParsed.subdivisions[subDivision]);
  if(subDivisionRange <= 0) subDivisionRange = 400; // random 400
  //log.debug("user is in subdivision " + subDivision);

  //matchmaking code
  //let's get subdivision and neighbouring subdivisions
  var subDivKeys = ["RecSubDivision"+subDivision];
  var titleData = server.GetTitleInternalData(
    {
      Keys : "RecSubDivision"+subDivision
    }
    );
  var recPool = titleData.Data["RecSubDivision"+subDivision];
  var isIncompleteSubDivision = false;
  //log.debug("recPool " + recPool);
  if(recPool == undefined) isIncompleteSubDivision = true;
  var recArray;
  var opponentId;
  var env;
  var course;

//previous opponents + win status
var oppPrev = "noop"; // ultimu
var oppPrevPrev = "noop";// penultimu
var oppArray;
var oppDat = server.GetUserInternalData(
{
    PlayFabId: currentPlayerId,
    Keys: ["lastOpp", "quitLastGame"]
});

var didQuitLastGame = oppDat.Data.quitLastGame.Value;
if(args.debug == true) log.debug("didQuitLastGame: " + didQuitLastGame);
var setLastGameToLossFlag = false;
if(didQuitLastGame == undefined) didQuitLastGame = "false";
if(didQuitLastGame == "true") 
{
  //user quit so we have to set his last game to a loss
  setLastGameToLossFlag = true; //urhereson
}
if((oppDat.Data == undefined) || (oppDat.Data.lastOpp == undefined))
{
  //log.debug("opp data is undefined");
  oppPrev = "noop";
  oppPrevPrev = "noop";
}
else
{
  oppArray = oppDat.Data.lastOpp.Value.split(",");
 // log.debug("oppArray is " + oppArray);
  for(var i = 0; i < oppArray.length; i++)
  {
    if(i == 0) oppPrev = oppArray[i];
    if(i == 1) oppPrevPrev = oppArray[i];
  }
 // log.debug("oppPrev is " + oppPrev);
 // log.debug("oppPrevPrev is " + oppPrevPrev);
}
  if(isIncompleteSubDivision == false)
  {
    recArray = JSON.parse(recPool);
    opponentId = recArray[recArray.length - 1].uId;
    env = recArray[recArray.length - 1].e;
    course = recArray[recArray.length - 1].c;
  }
  else
  {
    recArray = [];
  }

  //default recording code
  var subDivisionLength = 15; // we have 15 possible courses
  var envCourseArray =
  [
  0,0,0,0,0,
  0,0,0,0,0,
  0,0,0,0,0
  ]
  //log.debug("subrecording pool has " + recArray.length + " length. Must have: " + subDivisionLength + " length");

  if(recArray.length < subDivisionLength) isIncompleteSubDivision = true;

  var validRecArray = new Array(recArray.length); // all recordings except yours
  var vrAidx = 0;
  var likelyRecArray = new Array(recArray.length); // all recordings minus yours AND minus oppPrev
  var lrAidx = 0;
  var moreLikelyRecArray = new Array(recArray.length); // all recordings minus yours AND minus oppPrev AND minus oppPrevPrev
  var mlrAidx = 0;
  //log.debug("iterating through recArray");
  for(var i = 0; i < recArray.length; i++) // create valid rec pool OR check for missing env/course if subDivision has missing recordings
  {
      if(isIncompleteSubDivision == true)
      {
        envCourseArray[Number(recArray[i].e)*5 + Number(recArray[i].c)] = 1;
      }
      if(recArray[i].uId == currentPlayerId)
        {
         // log.debug("found: " + recArray[i].uId + "... skipping");
          continue;
        }
        validRecArray[vrAidx] = recArray[i];
        vrAidx++;
      if(recArray[i].uId == oppPrev)
        {
         // log.debug("found: " + recArray[i].uId + "... skipping prev opp");
          continue;
        }
        likelyRecArray[lrAidx] = recArray[i];
        lrAidx++;
      if(recArray[i].uId == oppPrevPrev)
        {
         // log.debug("found: " + recArray[i].uId + "... skipping prev prev opp");
          continue;
        }
        moreLikelyRecArray[mlrAidx] = recArray[i];
        mlrAidx++;
  }
//log.debug("isIncompleteSubDivision: " + isIncompleteSubDivision);
//let's give default recording if necessary
if(isIncompleteSubDivision == true)
{
  var envToGet = 0;
  var courseToGet = 0;
  var recordlessTracks = [];

  for(var i = 0; i < envCourseArray.length; i++)
  {
    if(envCourseArray[i] == 0)// we found a missing recording <- e = i/5; c = i%5;
    {
      recordlessTracks.push(i);
    }
  }

  var courseIndexMissing = recordlessTracks[Math.floor(Math.random() * recordlessTracks.length)];
      envToGet = Math.floor(courseIndexMissing/5);
      courseToGet = courseIndexMissing%5;

  //log.debug("gettingDefaultUser: env: " + envToGet + " course: " + courseToGet);
  //let's see who the master account is
    var masterAccountRequest = server.GetTitleData(
    {
      Keys : "MasterUser"
    }
    );
    if(masterAccountRequest.Data["MasterUser"] != undefined)
    {
     // log.debug("master user: " + masterAccountRequest.Data["MasterUser"]);
      var defaultRecordingData = server.GetUserReadOnlyData(
      {
        PlayFabId: masterAccountRequest.Data["MasterUser"],
        Keys: [(envToGet + "_" + courseToGet + "_RecPos") , (envToGet + "_" + courseToGet + "_RecRot"), (envToGet + "_" + courseToGet + "_RecHeader")]
      }
      );
      if(defaultRecordingData.Data != undefined)
      {
        //log.debug("defaultRecordingData: " + defaultRecordingData.Data);
        if((defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecPos"] != undefined) && (defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecRot"] != undefined) && (defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecHeader"] != undefined))
        { // looks like we found a valid default recording
          var updateTrophyInternal = true;
          if(trophyCount == 0)
          {
            trophyCount = rMax;
            updateTrophyInternal = false;
          }
          else
          {
            trophyCount -= lMin;
          }
          if(trophyCount <= 1) trophyCount = 1;
          //wlStatInt = parseInt(wlStat, 2);

          //log.debug("updating WL to:  " + wlStatInt);
          //update stats on server
          var suArray = [];
          //var su = {StatisticName: "WinLoss", Version : "0", Value: wlStatInt};
          //suArray.push(su);
          var sut = {StatisticName: "TrophyCount", Version : "0", Value: trophyCount};
          suArray.push(sut);
          var sul = {StatisticName: "League", Version : "0", Value: cLeague};
          suArray.push(sul);
          var sul = {StatisticName: "TotalGames", Version : "0", Value: totalGamesStarted};
          suArray.push(sul);
          //log.debug("updatingStats: " + suArray);
          var updateRequest = server.UpdatePlayerStatistics(
          {
            PlayFabId: currentPlayerId,
            Statistics: suArray
          }
          );

          var trophiesOnWin = Math.floor((Number(rMax) + Number(rMin))/2);
          var trophiesOnLose = Math.floor((Number(lMax) + Number(lMin))/2);

          var dataToUpdate = {
            "trophyWin" : trophiesOnWin,
            "trophyLose": trophiesOnLose,
            "quitLastGame" : "true",
          }

          if(updateTrophyInternal == false)
          {
            dataToUpdate["trophyWin"] = 0;
            dataToUpdate["trophyLose"] = 0;
          }
          if(setLastGameToLossFlag == true)//urhere
          {
            dataToUpdate["LastGameOutcome"] = "Loss";
          }
          server.UpdateUserInternalData(
          {
            PlayFabId: currentPlayerId,
            Data: dataToUpdate
          });
          //log.debug("found valid default rec");
          return {
            Result :"OK",
            RecType: "TheStig",
            PosData: defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecPos"].Value, //0_0_RecPos
            RotData: defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecRot"].Value,
            HeaderData: defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecHeader"].Value,
            TrophyLose: lMin,
            TrophyWin : rMax,
            Opp: "TheStig"
                 };
        }
      }
    }
}
//log.debug("looking for user generated recording");
if(vrAidx == 0) return generateErrObj("no valid recording found for this subdivision");

//we have 3 arrays. We want the likelyhood that you get the same previous opponents to be as low as possible
//so we will see if moreLikelyRecArray is empty. If yes we check if likelyRecArray is empty.
//if they are both empty we remain with the current validRecArray array
var searchArray = validRecArray;
var sAlen = vrAidx;
  if(lrAidx > 0){sAlen = lrAidx; searchArray = likelyRecArray}
  if(mlrAidx > 0){sAlen = mlrAidx; searchArray = moreLikelyRecArray}
  var pivot = Math.floor(Math.random() * sAlen);
  if(pivot >= sAlen) pivot = sAlen - 1; //i'm not fully sure Math.random can't give a value of 1 DON'T JUDGE ME
//legacy WINLOSS RATIO mathcmaking
  //var pivot = sAlen - 1; //in case your WLRatio is the highest in the pool
  //for(var i = 0; i < sAlen; i++) // write winstreak/losestreak code
  //{
  //  if(searchArray[i].wl > winRatio) //let's find the pivot; we'll move it later based on WL ratio
  //  {
  //    pivot = i;
  //    break;
   // }
  //}
 // log.debug("pivot is: " + pivot);
  var finalRecArraySize = Math.min(sAlen, 3); // for now 3 is the max number of recordings in the random final pool
 // log.debug("finalRecArraySize: " + finalRecArraySize);
  var finalRecArray = new Array(finalRecArraySize); // this array will be populated with the recordings around the pivot
  for(var i = 0; i < finalRecArraySize; i++)
  {
    if(pivot <= 0) // get rightmost recordings
    {
      finalRecArray[i] = searchArray[i];
      continue;
    }
    if(pivot >= sAlen - 1) // get leftmost recordings
    {
      finalRecArray[i] = searchArray[sAlen - 1 - i];
      continue;
    }
    finalRecArray[i] = searchArray[(pivot - Math.floor(finalRecArraySize/2) + i)]; // get inner recordings
  }
  var randIdx = Math.floor(Math.random() * finalRecArraySize); // let's get a random one from this final pool
    opponentId = finalRecArray[randIdx].uId;
    env = finalRecArray[randIdx].e;
    course = finalRecArray[randIdx].c;
  var urodkr = [(env + "_" + course + "_RecPos") , (env + "_" + course + "_RecRot"), (env + "_" + course + "_RecHeader")];
 // log.debug("requesting " + urodkr);
  var recordingData = server.GetUserReadOnlyData(
    {
      PlayFabId: opponentId,
      Keys: urodkr
    }
    );
  if(recordingData == undefined) return generateErrObj("Did not find recording for this user: " + opponentId); // handle this later
  //end matchmaking

  var oI = server.GetPlayerCombinedInfo(
    {
      PlayFabId:opponentId,
      InfoRequestParameters: {"GetUserAccountInfo": true,"GetUserInventory": false,"GetUserVirtualCurrency": false,"GetUserData": false,"GetUserReadOnlyData": false,"GetCharacterInventories": false,"GetCharacterList": false, "GetTitleData": false,"GetPlayerStatistics": false}
    }
    );
  //found recording now let's reduce user's trophies
          //let's extract opponent trophies so we know how muany trophies we give/takeaway from user
          var trophiesToTake = 15; // min
          var trophiesToGive = 30; // max
          var userTrophies = trophyCount;
          var oppTrophies;
          var cLeague = Number(calculateLeague(trophyCount));
          var recTypeSent = "UserGenerated";
//log.debug("cLeague " + cLeague);
  //        log.debug("lsValParsed: " + lsValParsed);
  //        log.debug("sdvalParsed: " + sdvalParsed);
  //        log.debug("lsValParsed.leagues: " + lsValParsed.leagues);
  //        log.debug("sdvalParsed.subDivisions: " + sdvalParsed.subdivisions);

          var minLeagueT
          if(cLeague > 0)
            minLeagueT = Number(sdvalParsed.subdivisions[lsValParsed.leagues[cLeague - 1]]);
          else
            minLeagueT = 0;

          var maxLeagueT;
          if(cLeague >= lsValParsed.leagues.length - 1)
            maxLeagueT = minLeagueT * 2;
          else
            maxLeagueT = Number(sdvalParsed.subdivisions[lsValParsed.leagues[cLeague]]);

//log.debug("maxLT " + maxLeagueT + " minLeagueT " + minLeagueT);
          if(args.debug == true) log.debug("I bet it will crash after this");
          var opponentHeader = JSON.parse(recordingData.Data[env + "_" + course + "_RecHeader"].Value);
          if(args.debug == true) log.debug("or not");
          if(opponentHeader != undefined)
          {
            oppTrophies = opponentHeader.Trophies;
          }
          oppTrophies = Number(oppTrophies);
          var trophyAdjustmentRequired = true;
          //let's adjust said trophies if needed and modify the header
          if(args.debug == true) log.debug("Adjusting trophies");

          if(excludedSubdivisionsFromTrophyAdjustment != undefined) 
          {
            if(args.debug == true) log.debug("excludedSubdivisionsFromTrophyAdjustment: " + excludedSubdivisionsFromTrophyAdjustment);
            for(var i = 0; i < excludedSubdivisionsFromTrophyAdjustment.length; i++)
            {
              if(subDivision == Number(excludedSubdivisionsFromTrophyAdjustment[i])) 
                {
                  if(args.debug == true) log.debug("in excluded subdivision: " + subDivision);
                  trophyAdjustmentRequired = false;
                  break;
                }
            }
          }
          if(trophyAdjustmentRequired == true)
          {
            if(Number(Math.abs(userTrophies - oppTrophies)) >= trophyMaxDifference)
            {
              if(args.debug == true) log.debug("generating new trophies. Reason: user trophies: " + userTrophies + " vs opponent trophies: " + oppTrophies);
              oppTrophies = userTrophies - trophyReadjustRange + Math.floor(Math.random() * trophyReadjustRange * 2);
              opponentHeader.Trophies = oppTrophies;
              if(args.debug == true) log.debug("performing stringify on recordingData header");
              recordingData.Data[env + "_" + course + "_RecHeader"].Value = JSON.stringify(opponentHeader); //hope this works

            }
          }
          //end trophy adjustments

          if(maxLeagueT - minLeagueT <= 0)
          {
              trophiesToTake = lMax;
              trophiesToGive = rMin;
          }
          else
          {
            if(Number(Math.abs(userTrophies - oppTrophies)) > Number(subDivisionRange))
            {
              trophiesToTake = Math.floor((lMin + lMax)/2) - 1 + Math.floor(Math.random() * 3);
              trophiesToGive = Math.floor((rMax + rMin)/2) - 1 + Math.floor(Math.random() * 3);
              //recTypeSent = "MobyDick"; // the difference in trophies is too damn high. Tell the client to generate a more appropriate opponent
            }
            else
            {
            //  log.debug("rMin: " + rMin + " userTrophies: " + userTrophies + " oppTrophies " + oppTrophies + " maxLeagueT " + maxLeagueT + " minLeagueT " + minLeagueT + " rMax: " + rMax);
              trophiesToTake = lMin + Math.floor((((userTrophies - oppTrophies)/(maxLeagueT - minLeagueT)) + 1) * ((lMax - lMin)/2));
              trophiesToGive = rMin + Math.floor((((oppTrophies - userTrophies)/(maxLeagueT - minLeagueT)) + 1) * ((rMax - rMin)/2));
            }
          }
          //let's also check if the opponent's Pr is in the appropriate range
          if(args.debug == true) log.debug("Opponent's PR is TOO DAMN HIGH! " + opponentHeader.Pr + " vs " + Number(sdprValParsed.subdivisions[Number(lsValParsed.leagues[cLeague - 1]) + 1]) + ". You are in subdivision: " + Number((lsValParsed.leagues[cLeague - 1]) + 1));
          if(opponentHeader.Pr > Number(sdprValParsed.subdivisions[Number(lsValParsed.leagues[cLeague - 1]) + 1]))
          {
            //log.debug("Opponent's PR is TOO DAMN HIGH! " + opponentHeader.Pr + " vs " + Number(sdprValParsed.subdivisions[lsValParsed.leagues[cLeague - 1] + 1]) + ". You are in subdivision: " + lsValParsed.leagues[cLeague - 1] + 1);
            trophiesToTake = Math.floor((lMin + lMax)/2) - 1 + Math.floor(Math.random() * 3);
            trophiesToGive = Math.floor((rMax + rMin)/2) - 1 + Math.floor(Math.random() * 3);
            recTypeSent = "MobyDick"; // the difference in Pr is too damn high. Tell the client to generate a more appropriate opponent
          }
  var updateTrophiesToGiveTake = true;
  if(trophyCount == 0)
  {
    updateTrophiesToGiveTake = false;
    trophyCount = rMax;
  }
  else
  {
    trophyCount -= Number(trophiesToTake);
    if(trophyCount <= 1) trophyCount = 1;
  }
  //log.debug("trophiesToTake:  " + trophiesToTake);
 // log.debug("trophiesToGive:  " + trophiesToGive);
  //wlStatInt = parseInt(wlStat, 2);
 // log.debug("updating WL to:  " + wlStatInt);
  //update stats on server
  var suArray = [];
  //var su = {StatisticName: "WinLoss", Version : "0", Value: wlStatInt};
  //suArray.push(su);
  var sut = {StatisticName: "TrophyCount", Version : "0", Value: trophyCount};
  suArray.push(sut);
  var sul = {StatisticName: "League", Version : "0", Value: cLeague};
  suArray.push(sul);
  var sul = {StatisticName: "TotalGames", Version : "0", Value: totalGamesStarted};
  suArray.push(sul);
 // log.debug("updatingStats: " + suArray);
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: suArray
  }
  );
  var lastOppVal = opponentId + "," + oppPrev;
            var dataToUpdate = {
            "trophyWin" : trophiesToGive,
            "trophyLose": trophiesToTake,
            "lastOpp" : lastOppVal,
            "quitLastGame" : "true",
          }
  if(updateTrophiesToGiveTake == false)
  {
          dataToUpdate["trophyWin"] = 0;
          dataToUpdate["trophyLose"] = 0;
  }
  if(setLastGameToLossFlag == true)//urhere
      {
          dataToUpdate["LastGameOutcome"] = "Loss";
      }
          server.UpdateUserInternalData(
          {
            PlayFabId: currentPlayerId,
            Data: dataToUpdate
          });


  return {
    Result :"OK",
    RecType: recTypeSent,
    PosData: recordingData.Data[env + "_" + course + "_RecPos"].Value, //0_0_RecPos
    RotData: recordingData.Data[env + "_" + course + "_RecRot"].Value,
    HeaderData: recordingData.Data[env + "_" + course + "_RecHeader"].Value,
    TrophyLose: trophiesToTake,
    TrophyWin : trophiesToGive,
    Opp: oI.InfoResultPayload.AccountInfo.TitleInfo.DisplayName
         };
}
handlers.updateCarCust = function(args, context)
{
  var mC = CheckMaintenanceAndVersion(args);
  if(mC != "OK") return generateMaintenanceOrUpdateObj(mC);
  var userInv = server.GetUserInventory(
  {
    PlayFabId : currentPlayerId,
  }
  );
  var itemsToGive = [];
  var carFound = "-1";
  var DataToUpdate = {};
  var customizations = {
    PaintJobs : { itemOwned : "no", itemCustData: args.paintId, carItemId : "PaintId" },
    Decals : { itemOwned : "no", itemCustData: args.decalId, carItemId : "DecalId" },
    Plates : { itemOwned : "no", itemCustData: args.platesId, carItemId : "PlatesId" },
    Rims : { itemOwned : "no", itemCustData: args.rimsId, carItemId : "RimsId" },
    WindshieldText : { itemOwned : "no", itemCustData: args.wsId, carItemId : "WindshieldId" }
  };

  for(var i = 0; i < userInv.Inventory.length; i++)
  {
    if((userInv.Inventory[i].ItemId == args.carId) && (userInv.Inventory[i].CatalogVersion == "CarsProgress"))
    {
      carFound = userInv.Inventory[i].ItemInstanceId;
    }
    if(userInv.Inventory[i].ItemId in customizations)
    {
      customizations[userInv.Inventory[i].ItemId].itemOwned = "yes";
      if(customizations[userInv.Inventory[i].ItemId].itemCustData in userInv.Inventory[i].CustomData)
      {
        DataToUpdate[customizations[userInv.Inventory[i].ItemId].carItemId] = customizations[userInv.Inventory[i].ItemId].itemCustData;
      }
      else
      {
        log.debug("user doesn't own: " + userInv.Inventory[i].ItemId + " " + customizations[userInv.Inventory[i].ItemId].itemCustData);
      }
    }
  }
  if(carFound == "-1")
  {
    return generateFailObj("User does not own car with id: " + args.carId);
  }
    //give inventory
  for (var prop in customizations)
  {
    if (customizations.hasOwnProperty(prop))
    {
        if(customizations[prop].itemOwned == "no")
        {
           itemsToGive.push(prop);
        }
    }
  }

  if(DataToUpdate == {}) return generateFailObj("User doesn't own any of those customizations");
  server.UpdateUserInventoryItemCustomData(
     {
       PlayFabId: currentPlayerId,
       ItemInstanceId: carFound,
       Data: DataToUpdate
     }
     );
  var objectsUpdated =
  [
  {
    ItemId : args.carId,
    CatalogVersion: "CarsProgress",
    CustomData : DataToUpdate
  }
  ];
  if(itemsToGive.length > 0)
  {
    var grantRequest = server.GrantItemsToUser(
    {
      CatalogVersion : "Customization",
      PlayFabId: currentPlayerId,
      ItemIds : itemsToGive
    }
    );

    var InvData = {
      0 : "Owned"
    };

   for(var i = 0; i < grantRequest.ItemGrantResults.length; i++)
  {
    server.UpdateUserInventoryItemCustomData(
         {
           PlayFabId: currentPlayerId,
           ItemInstanceId: grantRequest.ItemGrantResults[i].ItemInstanceId,
           Data: InvData
         }
         );
  }
  }
  var invChangeObj =
      {
          Inventory: objectsUpdated
      };
  var returnObj = {
    Result: "OK",
    Message: "InventoryUpdate",
    InventoryChange:invChangeObj
  };
  return returnObj;

};
function upgradeCar(args, userInventoryObject, playerSC, playerHC)
{
  var carCardsCatalog = server.GetCatalogItems(
    {
      CatalogVersion : "CarCards"
    }
  );

  var carFound = false;
  var car;
  for(var i = 0; i < userInventoryObject.Inventory.length; i++)
  {
    if((userInventoryObject.Inventory[i].ItemId == args.carId) && (userInventoryObject.Inventory[i].CatalogVersion == "CarsProgress"))
    {
      carFound = true;
      //log.debug("car is in user's inventory!");
      car = userInventoryObject.Inventory[i];
      break;
    }
  }
  var cardInfo;
  for(i = 0; i < carCardsCatalog.Catalog.length; i++)
  {
    if(carCardsCatalog.Catalog[i].ItemId == args.carId)
    {
      cardInfo = JSON.parse(carCardsCatalog.Catalog[i].CustomData);
      //log.debug("cardInfo found!");
      break;
    }
  }

  if(cardInfo === undefined)
  return generateErrObj("CardNotFoundForCarwithID: " + args.carId + ". It is possible that the carCard ID and the Car ID do not coincide. Check Playfab catalog data.");

  if(carFound === true)
  {
    //test if maximum pr level was reached
    var newLvl = (parseInt(car.CustomData.CarLvl) + 1);
    if(newLvl >= Number(cardInfo.prPerLvl.length))
        return generateFailObj("Maximum pr level was reached!");

    var currCost = getObjectValueFromLevel(cardInfo, "currCostPerLvl", newLvl);
    var costCheckObj = checkBalance(cardInfo.currType, currCost, playerSC, playerHC);
    if(costCheckObj != "OK") return costCheckObj;


    //log.debug("user has enough currency. Let's check for card balance");

    var cardCost =  getObjectValueFromLevel(cardInfo, "cardCostPerLvl", newLvl);
    car.CustomData.CarLvl = newLvl;
    // log.debug("cardCost: " + cardCost);
    var cardFound = false;
    var cardData;
    for(i = 0; i < userInventoryObject.Inventory.length; i++)
    {
      if((userInventoryObject.Inventory[i].ItemId == args.carId) && (userInventoryObject.Inventory[i].CatalogVersion == "CarCards"))
      {
        // log.debug("consuming: " + userInventoryObject.Inventory[i].ItemInstanceId);
        cardFound = true;
        try
        {
          //old consume code
          // var itemConsumptionResult = server.ConsumeItem(
          //  {
          //    PlayFabId: currentPlayerId,
          //    ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
          //    ConsumeCount:cardCost
          //  }
          //);
          //new consume code
          if(userInventoryObject.Inventory[i].CustomData === undefined)//let's check if item has custom data
          {
            return generateFailObj("Insufficient cards, CusotmData undefined");
          }
          else
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount === undefined)//let's check if item has amount custom data
            {
              return generateFailObj("Insufficient cards, CusotmData.Amount udnefined");
            }
            else // let's check and see if the user has sufficent cards
            {
              if(Number(userInventoryObject.Inventory[i].CustomData.Amount) >= cardCost) // he does so let's remove the appropriate amount
              {
                userInventoryObject.Inventory[i].CustomData.Amount -= cardCost;
                cardData = {"Amount" : userInventoryObject.Inventory[i].CustomData.Amount};
                server.UpdateUserInventoryItemCustomData(
                  {
                    PlayFabId: currentPlayerId,
                    ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
                    Data: cardData
                  }
                );
              }
              else
              {
                return generateFailObj("Insufficient cards for real: " + userInventoryObject.Inventory[i].CustomData.Amount + " vs " + cardCost);
              }
            }
          }
        }
        catch(err)
        {
          //log.debug("itemConsumptionResult.errorCode " + err);
          return generateFailObj("Insufficient cards");
        }
        break;
      }
    }

    if(cardFound === false)
    {
      return generateFailObj("No cards found");
    }
    // log.debug("user has enough cards to purchase upgrade!");

    var newPr = recalculateCarPr(car.CustomData, car.ItemId, carCardsCatalog, undefined);
    // log.debug("upgrading to car lvl: " +  newLvl + " and pr: " + newPr);
    var CarData = {
      "CarLvl" : newLvl,
      "Pr" : newPr
    };
    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: car.ItemInstanceId,
        Data: CarData
      }
    );
    var subtractUserCurrencyResult;
    if(currCost > 0){
      subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
        {
          PlayFabId: currentPlayerId,
          VirtualCurrency : cardInfo.currType,
          Amount: currCost
        }
      );
      updateCurrencySpentStatistic(cardInfo.currType, currCost);
    }
    // log.debug("Upgrade Complete!");
    
    var objectsUpdated =
    [
      {
        ItemId : args.carId,
        CatalogVersion: "CarCards",
        CustomData: cardData
      },
      {
        ItemId : args.carId,
        CatalogVersion: "CarsProgress",
        CustomData : CarData
      }
    ];

    var currencyUpdated = {};
    var i =
    {
      Inventory: objectsUpdated
    }
    if(subtractUserCurrencyResult!=undefined)
    {
      currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
      i.VirtualCurrency = currencyUpdated;
    }

    i.Experience = UpdateExperience("Balancing", "BalancingItem", "Car_" + cardInfo.rarity, newLvl, true);
    return generateInventoryChange("InventoryUpdate", i);
  }
  else
  {
    // log.debug("user doesn't have car: " +  args.carId + "... looking for card");
    var cardFound = false;
    var cardData;
    var carCardInstance;
    for(var i = 0; i < userInventoryObject.Inventory.length; i++)
    {
      if((userInventoryObject.Inventory[i].ItemId == args.carId) && (userInventoryObject.Inventory[i].CatalogVersion == "CarCards"))
      {
        //log.debug("consuming: " + userInventoryObject.Inventory[i].ItemInstanceId);
        cardFound = true;
        try
        {
          //old consume code
          //var itemConsumptionResult = server.ConsumeItem(
          // {
          //  PlayFabId: currentPlayerId,
          // ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
          //ConsumeCount: cardInfo.baseCardCost
          //  }
          //  );
          //new consume code
          if(userInventoryObject.Inventory[i].CustomData === undefined)//let's check if item has custom data
          {
            return generateFailObj("Insufficient cards, CustomData null");
          }
          else
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount === undefined)//let's check if item has amount custom data
            {
              return generateFailObj("Insufficient cards, CustomData.Amount null");
            }
            else // let's check and see if the user has sufficent cards
            {
              if(Number(userInventoryObject.Inventory[i].CustomData.Amount) >= Number(cardInfo.cardCostPerLvl[1])) // he does so let's remove the appropriate amount
              {
                carCardInstance = userInventoryObject.Inventory[i].ItemInstanceId;
                userInventoryObject.Inventory[i].CustomData.Amount -= cardInfo.cardCostPerLvl[1];
                cardData = {"Amount" : userInventoryObject.Inventory[i].CustomData.Amount};
              }
              else
              {
                return generateFailObj("Insufficient cards: " + userInventoryObject.Inventory[i].CustomData.Amount + " vs " + cardInfo.cardCostPerLvl[1] +".");
              }
            }
          }
        }
        catch(err)
        {
          return generateFailObj("Insufficient cards: " + err);
        }
        break;
      }
    }

    if(cardFound == false)
    {
      return generateFailObj("No cards found");
    }

    //log.debug("user has enough cards to purchase car. Checking if enough currency is availabe");

    var costCheckObj = checkBalance(cardInfo.currType, cardInfo.currCostPerLvl[1], playerSC, playerHC);
    if(costCheckObj != "OK") return costCheckObj;

    var itemsToGive = [];
    itemsToGive.push(args.carId);

    var carToGive = server.GrantItemsToUser(
      {
        CatalogVersion : "CarsProgress",
        PlayFabId: currentPlayerId,
        ItemIds : itemsToGive
      }
    );

    if(carToGive.ItemGrantResults[0].Result === false)
    {
      log.error("Something went wrong while giving user the item, refunding cards");
      //new refund code
      return generateFailObj("Something went wrong while giving user the item, refunding cards.");
    }
    else
    {
      server.UpdateUserInventoryItemCustomData(
        {
          PlayFabId: currentPlayerId,
          ItemInstanceId: carCardInstance,
          Data: cardData
        }
      );
    }
    var subtractUserCurrencyResult;
    if(cardInfo.currCostPerLvl[1] > 0){
      subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
        {
          PlayFabId: currentPlayerId,
          VirtualCurrency : cardInfo.currType,
          Amount: cardInfo.currCostPerLvl[1]
        }
      );
      updateCurrencySpentStatistic(cardInfo.currType, cardInfo.currCostPerLvl[1]);
    }

    var CarData = {
      "CarLvl" : "1",
      "EngineLvl" : "0",
      "ExhaustLvl" : "0",
      "GearboxLvl" : "0",
      "SuspensionLvl" : "0"
    };

    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carToGive.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
    );
    CarData = {
      "TiresLvl" : "0",
      "TurboLvl" : "0",
      "PaintId" : cardInfo.defaultPaintID,
      "DecalId" : "0",
      "RimsId" : "0"
    };
    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carToGive.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
    );
    CarData = {
      "PlatesId" : "0",
      "WindshieldId" : "0",
      "Pr" : (Number(cardInfo.basePr) + cardInfo.prPerLvl[1])
    };

    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carToGive.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
    );
    //if user doesn't have this paint job we give it to him/her
    var hasPaintJob = false;
    var hasPaintJobItem = false;
    var paintData;
    for(var i = 0; i < userInventoryObject.Inventory.length; i++)
    {
      if(userInventoryObject.Inventory[i].ItemId == "PaintJobs")
      {
        hasPaintJobItem = true;
        //log.debug("user has paintjobs");
        if(userInventoryObject.Inventory[i].CustomData != undefined)
        {
          // log.debug("user has paintjobs customData");
          if (cardInfo.defaultPaintID in userInventoryObject.Inventory[i].CustomData)
          {
            //log.debug("user has paintjob already");
            hasPaintJob = true;
          }
          else
          {
            // log.debug("user doesn't have paintjob");
            paintData = {}
            paintData[cardInfo.defaultPaintID] = "Owned";
          }
        }
        else // userInventoryObject.Inventory[i].CustomData == undefined
        {
          paintData = {}
          paintData[cardInfo.defaultPaintID] = "Owned";
        }
        if(paintData != undefined){
          server.UpdateUserInventoryItemCustomData(
            {
              PlayFabId: currentPlayerId,
              ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
              Data: paintData
            }
          );}
          break;
        }//end if "PaintJobs"
      }//end for

      if(hasPaintJobItem == false)
      {
        paintToGive = [];
        paintToGive.push("PaintJobs");
        var custToGive = server.GrantItemsToUser(
          {
            CatalogVersion : "Customization",
            PlayFabId: currentPlayerId,
            ItemIds : paintToGive
          }
        );

        var paintData = {};
        paintData[cardInfo.defaultPaintID] = "Owned";
        server.UpdateUserInventoryItemCustomData(
          {
            PlayFabId: currentPlayerId,
            ItemInstanceId: custToGive.ItemGrantResults[0].ItemInstanceId,
            Data: paintData
          }
        );

      }

      //create function result object for new car
      CarData = {
        "CarLvl" : "1",
        "EngineLvl" : "0",
        "ExhaustLvl" : "0",
        "GearboxLvl" : "0",
        "SuspensionLvl" : "0"    ,
        "TiresLvl" : "0",
        "TurboLvl" : "0",
        "PaintId" : cardInfo.defaultPaintID,
        "DecalId" : "0",
        "RimsId" : "0"   ,
        "PlatesId" : "0",
        "WindshieldId" : "0",
        "Pr" : Number(cardInfo.basePr) + cardInfo.prPerLvl[1]
      };
      var objectsUpdated =
      [
        {
          ItemId : args.carId,
          CatalogVersion: "CarCards",
          CustomData: cardData
        },
        {
          ItemId : args.carId,
          CatalogVersion: "CarsProgress",
          CustomData : CarData
        }
      ];

      if(hasPaintJob == false)
      {
        var paintDataUpdateObj = {};
        paintDataUpdateObj[cardInfo.defaultPaintID] = "Owned";
        var pObj =
        {
          ItemId : "PaintJobs",
          CatalogVersion: "Customization",
          CustomData : paintDataUpdateObj
        }
        objectsUpdated.push(pObj);
      }

      var currencyUpdated = {};

      i =
      {
        Inventory: objectsUpdated
      }
      if(subtractUserCurrencyResult != undefined)
      {
        currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
        i.VirtualCurrency =currencyUpdated;
      }

      i.Experience = UpdateExperience("Balancing", "BalancingItem", "Car_" + cardInfo.rarity, 1, true);
      return generateInventoryChange("InventoryUpdateNewCar", i);
    }
  }
function upgradePart(args, userInventoryObject, playerSC, playerHC)
{
  var carCatalog = server.GetCatalogItems(
    {
      CatalogVersion : "CarsProgress"
    }
  );

  var carExists = false;
  for(var i = 0; i < carCatalog.Catalog.length; i++)
  {
    if(carCatalog.Catalog[i].ItemId == args.carId)
    {
      carExists = true;
      break;
    }
  }

  if(carExists === false)
  return generateErrObj("car with ID: " + args.carId + " not found in catalog.");

  // log.debug("Checking to see if part exists in catalog");
  var partsCatalog = server.GetCatalogItems(
    {
      CatalogVersion : "PartCards"
    }
  );

  var partExists = false;
  var cardInfo;
  for(var i = 0; i < partsCatalog.Catalog.length; i++)
  {
    if(partsCatalog.Catalog[i].ItemId == args.partId)
    {
      cardInfo = JSON.parse(partsCatalog.Catalog[i].CustomData);
      partExists = true;
      break;
    }
  }


  if(partExists == false)
  return generateErrObj("part with ID: " + args.partId + " not found in catalog.");

  //log.debug("Checking to see if user has car: " + args.carId);
  var carFound = false;
  var car;
  for(var i = 0; i < userInventoryObject.Inventory.length; i++)
  {
    if((userInventoryObject.Inventory[i].ItemId == args.carId) && (userInventoryObject.Inventory[i].CatalogVersion == "CarsProgress"))
    {
      carFound = true;
      //log.debug("car is in user's inventory!");
      car = userInventoryObject.Inventory[i];
      break;
    }
  }

  if(carFound === false)
  {
    return generateFailObj("car with ID: " + args.carId + " not found in user inventory.");
  }
  // log.debug("Checking to see if user has part and or has enough parts");
  var partFound = false;
  var part;
  var newlvl = 0;
  var CarDataToBeUpdated = {};
  for(i = 0; i < userInventoryObject.Inventory.length; i++)
  {
    if((userInventoryObject.Inventory[i].ItemId == args.partId) && (userInventoryObject.Inventory[i].CatalogVersion == "PartCards"))
    {
      partFound = true;
      //log.debug("part is in user's inventory!");
      part = userInventoryObject.Inventory[i];
      var tempDict =
      {
        Exhaust: "ExhaustLvl",
        Engine: "EngineLvl",
        Gearbox:"GearboxLvl",
        Suspension: "SuspensionLvl",
        Tires: "TiresLvl",
        Turbo: "TurboLvl"
      };

      newlvl = parseInt(car.CustomData[tempDict[args.partId]]) + 1;

      //test if maximum pr level was reached
      if(newlvl >= Number(cardInfo.prPerLvl.length))
          return generateFailObj("Maximum pr level was reached!");

      var partsRequired = getObjectValueFromLevel(cardInfo, "cardCostPerLvl", newlvl);
      var currCost = getObjectValueFromLevel(cardInfo, "currCostPerLvl", newlvl);

      CarDataToBeUpdated[tempDict[args.partId]] = newlvl;
      car.CustomData[tempDict[args.partId]] = newlvl;
      // log.debug("we need: " + partsRequired + " cards and " + currCost + " money => base: " + parseInt(cardInfo.baseCurrCost) + " lvls: " + parseInt(car.CustomData[tempDict[args.partId]]) + " perLvlCost: " + parseInt(cardInfo.currCostPerLvl) + " equalling: "  + ((parseInt(car.CustomData[tempDict[args.partId]], 10) * parseInt(cardInfo.currCostPerLvl, 10))));
      var updateCardData;
      var costCheckObj = checkBalance(cardInfo.currType, currCost, playerSC, playerHC);
      if(costCheckObj != "OK") return costCheckObj;
      // log.debug("consuming part instance: " + userInventoryObject.Inventory[i].ItemInstanceId);
      try
      {
        if(userInventoryObject.Inventory[i].CustomData === undefined)//let's check if item has custom data
        {
          return generateFailObj("Insufficient cards");
        }
        else
        {
          if(userInventoryObject.Inventory[i].CustomData.Amount === undefined)//let's check if item has amount custom data
          {
            return generateFailObj("Insufficient cards");
          }
          else // let's check and see if the user has sufficent cards
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount >= partsRequired) // he does so let's remove the appropriate amount
            {
              userInventoryObject.Inventory[i].CustomData.Amount -= partsRequired;
              updateCardData = {"Amount" : userInventoryObject.Inventory[i].CustomData.Amount};
              server.UpdateUserInventoryItemCustomData(
                {
                  PlayFabId: currentPlayerId,
                  ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
                  Data: updateCardData
                }
              );
            }
            else
            {
              return generateFailObj("Insufficient cards");
            }
          }
        }
      }
      catch(err)
      {
        // log.debug("itemConsumptionResult.errorCode " + err);
        return generateFailObj("Insufficient cards");
      }
      break; //for search
    }//if in inventory

  }//for
  if(partFound == false)
  {
    return generateFailObj("Part not found");
  }
  var subtractUserCurrencyResult;
  if(currCost>0)
  {
    subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : cardInfo.currType,
        Amount: currCost
      }
    );
    updateCurrencySpentStatistic(cardInfo.currType, currCost);
  }
  var newPr = recalculateCarPr(car.CustomData, car.ItemId, undefined, partsCatalog);
  CarDataToBeUpdated.Pr = newPr;

  server.UpdateUserInventoryItemCustomData(
    {
      PlayFabId: currentPlayerId,
      ItemInstanceId: car.ItemInstanceId,
      Data: CarDataToBeUpdated
    }
  );
  var objectsUpdated =
  [
    {
      ItemId : args.partId,
      CatalogVersion: "PartCards",
      CustomData: updateCardData
    },
    {
      ItemId : args.carId,
      CatalogVersion: "CarsProgress",
      CustomData : CarDataToBeUpdated
    }
  ];
  // log.debug("succesfully upgraded part!");



  var currencyUpdated = {};
  i ={Inventory: objectsUpdated};
  if(subtractUserCurrencyResult !== undefined)
  {
    currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
    i.VirtualCurrency = currencyUpdated;
  }

  i.Experience = UpdateExperience("Balancing", "BalancingItem", "Parts_" + cardInfo.rarity, newlvl, true);
  return generateInventoryChange("InventoryUpdatePart", i);
}
