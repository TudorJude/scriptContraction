function checkCarDataValidity(inventoryCarData, carCardsCatalog)
{
  if(inventoryCarData.CustomData == undefined)
  {
    try
    {
      var CarData = {
        "CarLvl" : "1",
        "EngineLvl" : "0",
        "ExhaustLvl" : "0",
        "GearboxLvl" : "0",
        "SuspensionLvl" : "0"
      };

      server.UpdateUserInventoryItemCustomData(
        {
          PlayFabId: currentPlayerId,
          ItemInstanceId: inventoryCarData.ItemInstanceId,
          Data: CarData
        }
      );
      CarData = {
        "TiresLvl" : "0",
        "TurboLvl" : "0",
        "PaintId" : "0",
        "DecalId" : "0",
        "RimsId" : "0"
      };
      server.UpdateUserInventoryItemCustomData(
        {
          PlayFabId: currentPlayerId,
          ItemInstanceId: inventoryCarData.ItemInstanceId,
          Data: CarData
        }
      );
      var pr = 0;
      for(var i =0; i < carCardsCatalog.Catalog.length; i++)
      {
        if(carCardsCatalog.Catalog[i].ItemId == inventoryCarData.ItemId)
        {
          var carCardInfo = JSON.parse(carCardsCatalog.Catalog[i].CustomData);
          pr = parseInt(carCardInfo.basePr);
          break;
        }
      }
      CarData = {
        "PlatesId" : "0",
        "WindshieldId" : "0",
        "Pr" : pr
      };
      server.UpdateUserInventoryItemCustomData(
        {
          PlayFabId: currentPlayerId,
          ItemInstanceId: inventoryCarData.ItemInstanceId,
          Data: CarData
        }
      );
    }
    catch(err)
    {
      return "PlayFabError";
    }
    var newData = {
      "CarLvl" : "1",
      "EngineLvl" : "0",
      "ExhaustLvl" : "0",
      "GearboxLvl" : "0",
      "SuspensionLvl" : "0",
      "TiresLvl" : "0",
      "TurboLvl" : "0",
      "PaintId" : "0",
      "DecalId" : "0",
      "RimsId" : "0" ,
      "PlatesId" : "0",
      "WindshieldId" : "0",
      "Pr" : pr
    };
    return newData;
  }
  return "OK";
}
function generateFailObj(mess)
{
  var retObj = {
    Result: "Failed",
    Message: mess
  };
  return retObj;
}

function generateErrObj(mess)
{
  var retObj = {
    Result: "Error",
    Message: mess
  };
  return retObj;
}

function generateInventoryChange(mess, inventory)
{
  var r = {
    Result: "OK",
    Message: mess,
    InventoryChange:inventory
  };
  return r;
}

function checkBalance(currType, cost, userSCBalance, userHCBalance)
{
  if(currType == "SC")
  {
    if(userSCBalance < cost)
    return generateFailObj("NotEnoughSC");
  }
  else
  {
    if(userHCBalance < cost)
    return generateFailObj("NotEnoughHC");
  }
  return "OK";
}

function calculateLeague(currentTrophies)
{
  var league = 1;
  var td = server.GetTitleData(
    {
      Keys : ["LeagueSubdivisions", "SubdivisionTrophyRanges"]
    });
    if(td.Data["LeagueSubdivisions"] == undefined) return league;
    if(td.Data["SubdivisionTrophyRanges"] == undefined) return league;
    var leaguesSubdivisions = JSON.parse(td.Data.LeagueSubdivisions);
    var leaguesSubdivisionsParsed = leaguesSubdivisions.leagues;
    var sdvtr = JSON.parse(td.Data.SubdivisionTrophyRanges);
    var sdvtrParsed = sdvtr.subdivisions;

    for(var i = 0; i < leaguesSubdivisionsParsed.length; i++)
    {
      if(Number(currentTrophies) > Number(sdvtrParsed[leaguesSubdivisionsParsed[i]]))
      continue;
      return i;
    }
  }

  function recalculateCarPr(CarData, carId, _carCardsCatalog, _partsCardCatalog)
  {
    var pr = 0;
    var carCardsCatalog;
    if(_carCardsCatalog === undefined)
    {
      carCardsCatalog = server.GetCatalogItems(
        {
          CatalogVersion : "CarCards"
        }
      );
    }
    else
    {
      carCardsCatalog = _carCardsCatalog;
    }
    for(var i = 0; i < carCardsCatalog.Catalog.length; i++)
    {
      if(carCardsCatalog.Catalog[i].ItemId == carId)
      {
        var carCardInfo = JSON.parse(carCardsCatalog.Catalog[i].CustomData);
        pr = parseInt(carCardInfo.basePr) + getObjectValueFromLevel(carCardInfo, "prPerLvl", CarData.CarLvl);
        break;
      }
    }

    //calcualte pr based on each part level
    var partCardsCatalog;
    if(_partsCardCatalog === undefined)
    {
      partCardsCatalog = server.GetCatalogItems(
        {
          CatalogVersion : "PartCards"
        }
      );
    }
    else
    {
      partCardsCatalog = _partsCardCatalog;
    }

    var tempDict =
    {
      Exhaust: CarData.ExhaustLvl,
      Engine: CarData.EngineLvl,
      Gearbox: CarData.GearboxLvl,
      Suspension: CarData.SuspensionLvl,
      Tires: CarData.TiresLvl,
      Turbo: CarData.TurboLvl
    };
    var partCardInfo;
    for(i = 0; i < partCardsCatalog.Catalog.length; i++) //refactored
    {
      partCardInfo = JSON.parse(partCardsCatalog.Catalog[i].CustomData);
      pr += getObjectValueFromLevel(partCardInfo, "prPerLvl", Number(tempDict[partCardsCatalog.Catalog[i].ItemId]));
    }
    return pr;
  }

  function GenerateBlackMarket(currentPlayerId)
  {
    //getting user league
    var league = 1;
    var ps=server.GetPlayerStatistics(
      {
        PlayFabId: currentPlayerId,
        StatisticNames: ["League"]
      });
      if(ps.Statistics.length != 0)
      {
        league = ps.Statistics[0].Value.toString();
      }
      //getting parts
      var partsCatalog = server.GetCatalogItems(
        {
          CatalogVersion : "PartCards"
        }
      );
      var dataToUpdate = {};
      var d = new Date();
      dataToUpdate["BMTime"] = d.getTime();
      //get first part
      var part0Index = Math.floor(Math.random() * partsCatalog.Catalog.length);
      var cardParsed = JSON.parse(partsCatalog.Catalog[part0Index].CustomData);
      if(cardParsed == undefined) return generateErrObj("Part card " + partsCatalog.Catalog[i].ItemId + " has no custom data.");
      dataToUpdate["BMItem0"] = partsCatalog.Catalog[part0Index].ItemId + "_" + cardParsed.BMCurrType + "_" + cardParsed.BMbasePrice + "_" + 0 + "_" + cardParsed.BMpriceIncrPerBuy;
      //generate second part card
      var part1Index = Math.floor(Math.random() * partsCatalog.Catalog.length);
      if(part1Index == part0Index) part1Index = partsCatalog.Catalog.length - part0Index - 1;
      cardParsed = JSON.parse(partsCatalog.Catalog[part1Index].CustomData);
      if(cardParsed == undefined) return generateErrObj("Part card " + partsCatalog.Catalog[i].ItemId + " has no custom data.");
      dataToUpdate["BMItem1"] = partsCatalog.Catalog[part1Index].ItemId + "_" + cardParsed.BMCurrType + "_" + cardParsed.BMbasePrice + "_" + 0 + "_" + cardParsed.BMpriceIncrPerBuy;
      //getting car cards
      var carsCatalog = server.GetCatalogItems(
        {
          CatalogVersion : "CarCards"
        }
      );
      var carCardParsed;
      var nonRareIndexes = [];
      var rareIndexes = [];
      for(var i = 0; i < carsCatalog.Catalog.length; i++)
      {
        carCardParsed = JSON.parse(carsCatalog.Catalog[i].CustomData)
        if(carCardParsed == undefined) return generateErrObj("Car card " + carsCatalog.Catalog[i].ItemId + " has no custom data.");
        if(carCardParsed.unlockedAtRank > league + 1) continue;
        if(carCardParsed.rareCar == "false")
        nonRareIndexes.push(carsCatalog.Catalog[i].ItemId + "_" + carCardParsed.BMCurrType + "_" + carCardParsed.BMbasePrice + "_" + 0 + "_" + carCardParsed.BMpriceIncrPerBuy);
        else
        rareIndexes.push(carsCatalog.Catalog[i].ItemId + "_" + carCardParsed.BMCurrType + "_" + carCardParsed.BMbasePrice + "_" + 0 + "_" + carCardParsed.BMpriceIncrPerBuy);
      }
      if(nonRareIndexes.length <= 0)
      {
        dataToUpdate["BMItem2"] = rareIndexes[Math.floor(Math.random() * rareIndexes.length)];
        dataToUpdate["BMItem3"] = rareIndexes[Math.floor(Math.random() * rareIndexes.length)];
      }
      else
      if(rareIndexes.length <= 0)
      {
        dataToUpdate["BMItem2"] = nonRareIndexes[Math.floor(Math.random() * nonRareIndexes.length)];
        dataToUpdate["BMItem3"] = nonRareIndexes[Math.floor(Math.random() * nonRareIndexes.length)];
      }
      else
      {
        dataToUpdate["BMItem2"] = nonRareIndexes[Math.floor(Math.random() * nonRareIndexes.length)];
        dataToUpdate["BMItem3"] = rareIndexes[Math.floor(Math.random() * rareIndexes.length)];
      }
      server.UpdateUserInternalData(
        {
          PlayFabId : currentPlayerId,
          Data : dataToUpdate
        }
      );
      var tK = [];
      tK.push("BlackMarketResetMinutes");
      var tData = server.GetTitleData(
        {
          PlayFabId : currentPlayerId,
          Keys : tK
        }
      );
      dataToUpdate["BMTime"] = parseInt(tData.Data.BlackMarketResetMinutes) * 60;
      return dataToUpdate;
    }

    function GetCurrentBlackMarket(currentPlayerId, getInternalDataResult)
    {
      var bmObj = {};
      var d = new Date();

      var tK = [];
      tK.push("BlackMarketResetMinutes");
      var tData = server.GetTitleData(
        {
          PlayFabId : currentPlayerId,
          Keys : tK
        }
      );

      bmObj["BMTime"] = parseInt(tData.Data.BlackMarketResetMinutes) * 60 - Math.floor((d.getTime() - getInternalDataResult.Data.BMTime.Value) / 1000);
      for(var i = 0; i < 4; i++)
      {
        bmObj["BMItem" + i] = getInternalDataResult.Data["BMItem" + i].Value;
      }
      return bmObj;
    }



    /**
    * Returns the statistics value from the provided statistics array
    * @param {array} statisticsArray containing statistics objects
    * @param {string} statisticsName id of the searched statistic
    * @param {value} statisticsName (optional) default value returned if statistic is not found
    */
    function GetValueFromStatistics(statisticsArray, statisticsName, defaultValue)
    {
      var stat;
      //find statistic with given name
      for (var i = 0; i < statisticsArray.length; i++)
      if(statisticsArray[i].StatisticName === statisticsName)
      stat = statisticsArray[i];

      if(stat === undefined)
      return defaultValue !== undefined ? defaultValue : 0;
      else
      return Number(stat.Value);
    }

    /**
    * Returns catalog item or undifined
    * @param {string} catalogId the catalog id of the requested item
    * @param {string} itemId of the recuested item
    */
    function getCatalogItem(catalogId, itemId)
    {
      var items = server.GetCatalogItems({CatalogVersion : catalogId});
      for (var i = 0; i < items.Catalog.length; i++) {
        if(items.Catalog[i].ItemId === itemId)
        return items.Catalog[i];
      }

      return undefined;
    }


    /**
    * Returns the item value from the object with id itemId at index level
    * The given object must have a 'length' property used to clamp level inbounds
    * @param  {object} holdingObject, object in which itemId is searched
    * @param  {string} itemId, property id of the object that contains the desired value
    * @param  {int} level, index of the desired value
    * @param  {value} defaultValue, 0 if none provided
    * @return {value}, defaultValue or the value at index level in object itemId
    */
    function getObjectValueFromLevel(holdingObject, itemId, level, defaultValue) {
      if(!defaultValue) defaultValue = 0;
      if(!holdingObject[itemId] || !holdingObject[itemId].length) return defaultValue;

      // clamp ln to lenght is it can't get out of bounds
      var ln = Number(holdingObject[itemId].length);
      if(level >= ln) level = ln - 1;
      return Number(holdingObject[itemId][level]) || defaultValue;
    }
handlers.buyChest = function(args, context)
{
  var userInventoryObject=server.GetUserInventory(
  {
    PlayFabId:currentPlayerId
  });

  var bO = checkBalance(args.curr, args.cost, userInventoryObject.VirtualCurrency.SC, userInventoryObject.VirtualCurrency.HC);
  if(bO != "OK") return generateFailObj("not enough money");
  if(args.cost > 0)
  {
    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
    {
      PlayFabId: currentPlayerId,
      VirtualCurrency : args.curr,
      Amount: args.cost
    }
    );
    var cU = {};
    cU[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
    return generateInventoryChange("ChestBought", {VirtualCurrency: cU});
  }
  else
  {
    return generateInventoryChange("ChestBought", {});
  }
};
handlers.endGame = function(args, context) {
  //let's recalculate the player's win/loss ratio
  var wlStat = "01";
  var wlStatInt = 0;
  var curWL = "0";
  if(args.outcome == "rWin")curWL="1";
  var ps=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["WinLoss"]
  });
  if(ps.Statistics.length != 0)
  {
      wlStatInt = ps.Statistics[0].Value.toString();
      //log.debug("wlStatInt " + wlStatInt);
      wlStat = Number(wlStatInt).toString(2);
      //log.debug("wlStat " + wlStat);
  }
  var wins = 0;
  var totalGames = 2;
  var winRatio = 0;
  //log.debug("wlStat.length " + wlStat.length);
  var tempString = new Array(wlStat.length);
  //log.debug("tempString.length " + tempString.length);
  for(var i = 0 ; i < tempString.length - 1; i++)
  {
    tempString[i] = wlStat[i];
  }
	tempString[tempString.length-1] = curWL;
  //log.debug("tempString " + tempString);
  wlStat = tempString;
  //log.debug("wlStat " + wlStat);
	totalGames = wlStat.length;
	for(var i = 0; i < wlStat.length; i++)
	{
		if(wlStat[i] == "1") wins++;
	}
	//log.debug("wlStatNew " + wlStat);

  winRatio = Math.round( 100* (wins/totalGames));
  //log.debug("winRatio " + winRatio);
  //let's get some relevant title wide data
    var titleDataRequest = server.GetTitleData(
    {
      Key: ["LeagueSubdivisions","SubdivisionTrophyRanges"]
    }
    );
  //let's update user trophies
  var trophyCount = 0;
  var initTrophyCount = 0;
  var tc=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["TrophyCount"]
  });
  if(tc.Statistics.length != 0)
  {
    trophyCount = tc.Statistics[0].Value;
    log.debug("getting trophy count " + tc.Statistics[0].Value);
  }
  trophyCount = Number(trophyCount);
  initTrophyCount = trophyCount;
  var pDat = server.GetUserInternalData(
  {
    PlayFabId: currentPlayerId,
    Keys: ["trophyLose","trophyWin"]
  });
  var refund;
  //log.debug("pDat.Data[trophyLose] " + pDat.Data["trophyLose"].Value);
  //log.debug("pDat.Data[trophyWin] " + pDat.Data["trophyWin"].Value);
  if((pDat.Data["trophyLose"] == undefined) || (pDat.Data["trophyWin"] == undefined)) refund = 45;
  else refund = Number(pDat.Data["trophyLose"].Value) + Number(pDat.Data["trophyWin"].Value);
  //log.debug("refund: " + refund);
  if(args.outcome == "rWin")
  {
  		trophyCount += refund;
  }
  log.debug("trophies change: " + initTrophyCount + " => " + trophyCount);
  var cLeague = calculateLeague(trophyCount);
  wlStatInt = 0;
  for(var i = 0 ; i < wlStat.length; i++)
  {
    if(wlStat[i] == "1")
      wlStatInt += Math.pow(2,i);
  }
  //update stats on server
  var suArray = [];
  var su = {StatisticName : "WinLoss", Version : "0", Value: wlStatInt};
  suArray.push(su);
  var sut = {StatisticName : "TrophyCount", Version : "0", Value: trophyCount};
  suArray.push(sut);
  var sut = {StatisticName : "League", Version : "0", Value: cLeague};
  suArray.push(sut);
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: suArray
  }
  );
  //user ran out of time so we don't store recording
  //legacy code
  var recHeader = JSON.parse(args.recordingHeader);
  if(Number(recHeader.Score) <= 10)
    {
        var newPlayerStats =
        {
          "TrophyCount" : trophyCount,
          "League" : cLeague
        }
        return {Result : newPlayerStats};
    }
    //if the user has a score of 0 we get out of this function
    var recHeader = JSON.parse(args.recordingHeader);
    log.debug("score: " + recHeader.Score)
  //let's see which Subdivision this player is in
  var sdval = titleDataRequest.Data["SubdivisionTrophyRanges"];
  var sdvalParsed = JSON.parse(sdval);
  //log.debug("SubdivisionTrophyRanges " + sdvalParsed);
  var subDivision;
  for(var i = 0; i < sdvalParsed.subdivisions.length; i++)
  {
  	if(initTrophyCount<sdvalParsed.subdivisions[i])
  	{
		subDivision = i;
		break;
  	}
  }
//log.debug("user is in subdivision " + subDivision);
	//let's save the player's recording
 var dict = [];
    dict.push({
        Key:   args.envIndex+"_"+args.courseIndex+"_RecPos",
        Value: args.recordingPos
    });
      dict.push({
            Key:  args.envIndex+"_"+args.courseIndex+"_RecRot",
        Value: args.recordingRot
    });
       dict.push({
            Key:  args.envIndex+"_"+args.courseIndex+"_RecHeader",
        Value: args.recordingHeader
    });
       //log.debug("updating user read only data ");
  var playerData = server.UpdateUserReadOnlyData(
    {
      PlayFabId: currentPlayerId,
      Data:dict
    }
  );

  //log.debug("updated user read only data for " + currentPlayerId + " " + playerData);
  var titleDataVal = server.GetTitleInternalData(
    {
      Key: "RecSubDivision"+subDivision, //i.e RecSubDivision0,
    }
    );
  var recPool = titleDataVal.Data["RecSubDivision"+subDivision];
  //log.debug("recPool: " + recPool);
  var recArray;
  var titleKeyVal;
  if(recPool == undefined)
  {
  	recArray = [];
  	var recObj =
  	{
  		"wl": winRatio,
  		"e": args.envIndex,
  		"c": args.courseIndex,
  		"uId": currentPlayerId
  	}
  	recArray.push(recObj);
  	titleKeyVal = JSON.stringify(recArray);
  	//log.debug("recArray: " + titleKeyVal);
  }
  else
  {
  	recArray = JSON.parse(recPool);
  	//log.debug("recArray: " + recArray);
  	var recObj =
  	{
  		"wl": winRatio,
  		"e": args.envIndex,
  		"c": args.courseIndex,
  		"uId": currentPlayerId
  	}
  	var uniqueKeyExists = false;
    //let's only keep 2 recordings per user per subdivision at max
    var currentOccurencesOfPlayer = 0;
    for(var i = 0; i < recArray.length; i++)
    {
      if(recArray[i].uId == currentPlayerId)
        currentOccurencesOfPlayer++;
    }
    if(currentOccurencesOfPlayer > 2) // no use letting the user spam his recordings on the same subdivision
    {
      var newPlayerStats =
      {
          "TrophyCount" : trophyCount,
          "League" : cLeague
      }
      return {Result : newPlayerStats};
    }

  	for(var i = 0; i < recArray.length; i++)
  	{
  		if((recArray[i].e == args.envIndex)&&(recArray[i].c == args.courseIndex))
  		{
			uniqueKeyExists = true;
			recArray[i] = recObj;
			if(recArray.length == 1) break; //if it's the only recording there is no use to sort anymore
			if(i > 0) // if not first
			{
				if(recArray[i].wl > recArray[i-1].wl) // if bigger than left we start comparing to elements to the right
				{
					if(i == recArray.length-1) break; // there are no more elements to the right so no more sorting required
					for(var j = i + 1; j < recArray.length; j++) // we check elements i+1 to length-1
					{
						if(recArray[j - 1].wl > recArray[j].wl) // if wl of element j - 1 is greater than that of element j we swap them
						{
							var aux = recArray[j];
							recArray[j] = recArray[j - 1];
							recArray[j - 1] = aux;
						}
						else // the element stays where it is
						{
							break;
						}
					}
				}
				else // not bigger than the left let's start comparing with elements to the left
				{
					for(var j = i - 1; j >= 0; j--) // we check elements i-1 to 0
					{
						if(recArray[j + 1].wl < recArray[j].wl) // if wl of element j + 1 is smaller than that of element j we swap them
						{
							var aux = recArray[j];
							recArray[j] = recArray[j + 1];
							recArray[j + 1] = aux;
						}
						else // the element stays where it is
						{
							break;
						}
					}
				}
		    } // if(i > 0)
		    else
		    {
					for(var j = i + 1; j < recArray.length; j++) // we check elements i+1 to length-1
					{
						if(recArray[j - 1].wl > recArray[j].wl) // if wl of element j - 1 is greater than that of element j we swap them
						{
							var aux = recArray[j];
							recArray[j] = recArray[j - 1];
							recArray[j - 1] = aux;
						}
						else // the element stays where it is
						{
							break;
						}
					}
		    }
  		}
  	}
  	if(uniqueKeyExists == false)
  	{
  	 // log.debug("recArrayLNbefore: " + recArray.length);
  	  recArray.push(recObj);
  	  //log.debug("recArrayLNafter: " + recArray.length);
    }
  	titleKeyVal = JSON.stringify(recArray);
  //	log.debug("titleKeyVal: " + titleKeyVal);
  }

  var titleData = server.SetTitleInternalData(
    {
      Key: "RecSubDivision"+subDivision, //Recording_0_0
      Value: titleKeyVal
    }
    );
   var newPlayerStats =
     {
          "TrophyCount" : trophyCount,
          "League" : cLeague
      };
  return {Result : newPlayerStats};
}
/**
* Updates the amount of experience the user has based on given variables
* @param {string} catalogId the ID of the catalog holding xp data
* @param {string} itemId the id of the item holding xp data from the given catalog
* @param {string} xpArrayId the id of the object holding xp data from the give item
* @param {int} actionLevel the level of the exectued action (used to get the amount of xp to give)
* @param {bool} updateServer update experience to the server
* @param {int} playerStatistics array containing player experience, if not provided a GetPlayerStatistics will be done
*/
function UpdateExperience(catalogId, itemId, xpArrayId, actionLevel, updateServer, playerStatistics)
{
  //the amount of xp gained at each action level
  var xpGainByLevel = JSON.parse(getCatalogItem(catalogId, itemId).CustomData)[xpArrayId];

  //xp cap to stop the user to level up past a given level
  var lvlThresholds = JSON.parse(getCatalogItem("Balancing", "BalancingItem").CustomData).LevelThresholds;
  var xpCap = lvlThresholds[lvlThresholds.length - 1];

  //get current exprience
  var ps= playerStatistics || server.GetPlayerStatistics({
    PlayFabId: currentPlayerId,
    StatisticNames: ["Experience"]
  }).Statistics;
  var currentExprience = GetValueFromStatistics(ps, "Experience", 0);

  if(currentExprience >= xpCap)
    return xpCap;

  var xpToReceive = 0;
  if(!isNaN(Number(xpGainByLevel))){
    //action levels are represented by a single number value, the amount to give is xpGain
    xpToReceive = Number(xpGainByLevel);
    if(xpToReceive === 0) return currentExprience;
  }
  else {
    //action levels are represented by an object
    var ln = Number(xpGainByLevel.length);
    if(actionLevel >= ln) actionLevel = ln - 1;
    xpToReceive = Number(xpGainByLevel[actionLevel]);
  }

  //cap and update player's current experience
  currentExprience = Math.min(currentExprience + xpToReceive, xpCap);

  if(!updateServer) return currentExprience;
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: [{StatisticName: "Experience", Version : "0", Value: currentExprience}]
  });
  return currentExprience;
}
handlers.getServerTime = function(args, context)
{
	var t = new Date();
	return { time: t};
}
//cheat scripts
handlers.giveMoney = function(args)
{
  //args.curr, args.amount
  var addUserCurrencyResult = server.AddUserVirtualCurrency(
  {
    PlayFabId: currentPlayerId,
    VirtualCurrency : args.curr,
    Amount: args.amount
  }
  );

  var currencyUpdated = {};
  currencyUpdated[addUserCurrencyResult.VirtualCurrency] = addUserCurrencyResult.Balance;
  var invChangeObj =
           {
             VirtualCurrency: currencyUpdated
           };
  var r = {
         Result: "OK",
         Message: "CurrencyChanged",
         InventoryChange:invChangeObj
       };
  return r;
};
handlers.grantItems = function(args)
{
  //retrieve user inventory
  var userInventoryObject = server.GetUserInventory(
  {
    PlayFabId: currentPlayerId
  }
  );
  //args.itemId, args.catalogId, args.amount

  //old grant item code
  //var itemsToGrant = [];
  //for(var i = 0; i < args.amount; i++)
  //{
  //  itemsToGrant.push(args.itemId);
  //}
  //try
  //{
  // var grantVar = server.GrantItemsToUser(
  // {
  //  CatalogVersion : args.catalogId,
  //   PlayFabId: currentPlayerId,
  //   ItemIds : itemsToGrant
  // }
  // );
  //new grant item code
  var itemData;
  var itemFound = false;
  var newAmount;
  for(var i = 0; i < userInventoryObject.Inventory.length; i++)
        {
          if((userInventoryObject.Inventory[i].ItemId == args.itemId) && (userInventoryObject.Inventory[i].CatalogVersion == args.catalogId))
          {
           // log.debug("adding amount to: " + userInventoryObject.Inventory[i].ItemInstanceId);
            if(userInventoryObject.Inventory[i].CustomData == undefined)
            {
              newAmount = args.amount;
            }
            else
            {
              if(userInventoryObject.Inventory[i].CustomData.Amount == undefined)
                newAmount = args.amount;
              else
              {
                if(isNaN(Number(userInventoryObject.Inventory[i].CustomData.Amount)))
                  newAmount = args.amount;
                else
                  newAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + args.amount;
              }
            }
            itemData = {"Amount" : newAmount};
            server.UpdateUserInventoryItemCustomData(
                    {
                      PlayFabId: currentPlayerId,
                      ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
                      Data: itemData
                    }
                    );
            itemFound = true;
            break;
          }
        }

    if(itemFound == false)
    {
      var itemsToGrant = [];
      itemsToGrant.push(args.itemId);
      var grantVar = server.GrantItemsToUser(
      {
        CatalogVersion : args.catalogId,
        PlayFabId: currentPlayerId,
        ItemIds : itemsToGrant
      }
      );

      itemData = {"Amount" : args.amount};
      server.UpdateUserInventoryItemCustomData(
           {
              PlayFabId: currentPlayerId,
              ItemInstanceId: grantVar.ItemGrantResults[0].ItemInstanceId,
              Data: itemData
           }
           );
    }
   //for return
   var objectsUpdated =
   [
   {
     ItemId : args.itemId,
     CatalogVersion: args.catalogId,
     CustomData: itemData
   }
   ] ;
    var invChangeObj =
        {
            Inventory: objectsUpdated
        }
    var returnObj = {
      Result: "OK",
      Message: "InventoryUpdated",
      InventoryChange:invChangeObj
    };
   return returnObj;
}
handlers.initServerData = function(args)
{
//create trophy statistic
var suArray = [];

var su = {StatisticName : "TrophyCount", Version : "0", Value: "0"};
suArray.push(su);
su = {StatisticName : "League", Version : "0", Value: "0"};
suArray.push(su);

var updateRequest = server.UpdatePlayerStatistics(
{
  PlayFabId: currentPlayerId,
  Statistics: suArray
}
);
var itemsToGive = ["Decals","PaintJobs", "Plates", "Rims", "WindshieldText"];
//itemsToGive.push("Decals");
//itemsToGive.push("PaintJobs");
//itemsToGive.push("Plates");
//itemsToGive.push("Rims");
//itemsToGive.push("WindshieldText");

var grantRequest = server.GrantItemsToUser(
  {
    CatalogVersion : "Customization",
    PlayFabId: currentPlayerId,
    ItemIds : itemsToGive
  }
  );

var InvData = {"0" : "Owned"};

for(var i = 0; i < grantRequest.ItemGrantResults.length; i++)
{
  server.UpdateUserInventoryItemCustomData(
       {
         PlayFabId: currentPlayerId,
         ItemInstanceId: grantRequest.ItemGrantResults[i].ItemInstanceId,
         Data: InvData
       }
       );
}
var carsToGive = [];
carsToGive.push("FordFocus");
var carRequest = server.GrantItemsToUser(
{
  CatalogVersion : "CarsProgress",
  PlayFabId: currentPlayerId,
  ItemIds : carsToGive
}
);
var CarData = {"CarLvl" : "1","EngineLvl" : "0","ExhaustLvl" : "0","GearboxLvl" : "0","SuspensionLvl" : "0"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
  Data: CarData
}
);
CarData = {"TiresLvl" : "0","TurboLvl" : "0","PaintId" : "0","DecalId" : "0","RimsId" : "0"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
  Data: CarData
}
);
CarData = {"PlatesId" : "0","WindshieldId" : "0","Pr" : "10"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
  Data: CarData
}
);

var partsToGive = [];
partsToGive.push("Engine");
var partRequest = server.GrantItemsToUser(
{
  CatalogVersion : "PartCards",
  PlayFabId: currentPlayerId,
  ItemIds : partsToGive
}
);
var PartData = {"Amount" : "5"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: partRequest.ItemGrantResults[0].ItemInstanceId,
  Data: PartData
}
);
CarData = {"CarLvl" : "1","EngineLvl" : "0","ExhaustLvl" : "0","GearboxLvl" : "0","SuspensionLvl" : "0"};
server.UpdateUserInventoryItemCustomData(
{
  PlayFabId: currentPlayerId,
  ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
  Data: CarData
});
};
handlers.openChest = function(args, context)
{
  //level reward mechanic
  //args.level == -1 if it's regular open chest operation
  //args.level >= 0 if it's a reward for leveing up to level args.level
  if(args.isLevelUp == true)
  {
    var lastRewardLevel = server.GetUserReadOnlyData(
    {
      PlayFabId : currentPlayerId,
      Keys : ["LastLevelReward"]
    });
    var levelItemDataToUpdate = {};
    levelItemDataToUpdate["LastLevelReward"] = 1;
    log("lastLevelReward: " + lastRewardLevel.Data);
    if(lastRewardLevel.Data == undefined)
    {
      server.UpdateUserReadOnlyData(
      {
        PlayFabId : currentPlayerId, 
        Data : levelItemDataToUpdate
      }
        );

      var suArray = [];
      var su = {StatisticName : "Experience", Version : "0", Value: 0};
      suArray.push(su);

      server.UpdatePlayerStatistics(
      {
        PlayFabId : currentPlayerId,
        Statistics: suArray
      });

      //give bundle to user
      //ids of bundles are of the form 001, 002, ... , 012 etc so padded with 0s until it has 3 digits
      var str = "" + 1;
      var pad = "000";
      var ans = pad.substring(0, pad.length - str.length) + str; 
      server.GrantItemsToUser(
      {
        CatalogVersion : "LevelUpRewards",
        PlayFabId : currentPlayerId, 
        ItemIds : ans
      }
        );
      
    }
    else
    { 
      var lvlThresholds = JSON.parse(getCatalogItem("Balancing", "BalancingItem").CustomData).LevelThresholds;
        //get current exprience
      var ps= server.GetPlayerStatistics(
      {
            PlayFabId: currentPlayerId,
            StatisticNames: ["Experience"]
      }).Statistics;
      var currentExprience = GetValueFromStatistics(ps, "Experience", 0);
      var currLvl = 100;
      for(var i = 0; i < lvlThresholds.length; i++)
      {
        if(currentExprience >= lvlThresholds[i]) continue;
        currLvl = i; break;
      }

      if(Number(lastRewardLevel.Data.Value) < Number(currLvl))
      {
        lastRewardLevel.Data.Value = Number(lastRewardLevel.Data.Value) + 1;
        levelItemDataToUpdate["LastLevelReward"] = lastRewardLevel.Data.Value;
        server.UpdateUserReadOnlyData(
        {
          PlayFabId : currentPlayerId, 
          Data : levelItemDataToUpdate
        }
          );
        //give bundle to user
        //ids of bundles are of the form 001, 002, ... , 012 etc so padded with 0s until it has 3 digits
        var str = "" + lastRewardLevel.Data.Value;
        var pad = "000";
        var ans = pad.substring(0, pad.length - str.length) + str; 
        server.GrantItemsToUser(
        {
          CatalogVersion : "LevelUpRewards",
          PlayFabId : currentPlayerId, 
          ItemIds : ans
        }
          );      
        }
        else return generateFailObj("already got reward for level: " + lastRewardLevel.Data.Value);
    }
  }
  var objectsUpdated = [];
  var currencyUpdated = [];
  var invChangeObj;
  var userInventoryObject = server.GetUserInventory(
    {
      PlayFabId: currentPlayerId
    }
  );

  //let's check if this is a chest from the store
  if(args.currCost > 0)
  {
    var bO = checkBalance(args.currType, args.currCost, userInventoryObject.VirtualCurrency["SC"], userInventoryObject.VirtualCurrency["HC"])
    if(bO != "OK") return generateFailObj("not enough money");

    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : args.currType,
        Amount: args.currCost
      }
    );
  }
  //currency
  var addUserCurrencyResult;
  for(var p in args.currencyReq)
  {
    if(args.currencyReq[p] > 0)
    addUserCurrencyResult = server.AddUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : p,
        Amount: args.currencyReq[p]
      }
    );

  }
  var itemData;
  var itemFound = false;
  var newAmount = 0;
  //car cards
  for(var p in args.carCardsRequest)
  {
    //log.debug(p + " : " + args.carCardsRequest[p]);
    if (args.carCardsRequest.hasOwnProperty(p))
    {
      itemFound = false;
      newAmount = 0;
      //log.debug("looking for: " +p);
      for(var i = 0; i < userInventoryObject.Inventory.length; i++)
      {
        if((userInventoryObject.Inventory[i].ItemId == p) && (userInventoryObject.Inventory[i].CatalogVersion == "CarCards"))
        {
          // log.debug("adding amount to: " + userInventoryObject.Inventory[i].ItemInstanceId);
          if(userInventoryObject.Inventory[i].CustomData == undefined)
          {
            newAmount = Number(args.carCardsRequest[p]);
          }
          else
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount == undefined)
            newAmount = Number(args.carCardsRequest[p]);
            else
            {
              if(isNaN(Number(userInventoryObject.Inventory[i].CustomData.Amount)))
              newAmount = Number(args.carCardsRequest[p]);
              else
              newAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + Number(args.carCardsRequest[p]);
            }
          }
          itemData = {"Amount" : newAmount};
          server.UpdateUserInventoryItemCustomData(
            {
              PlayFabId: currentPlayerId,
              ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
              Data: itemData
            }
          );
          itemFound = true;
          break;
        }
      }
      if(itemFound == false)
      {
        var itemsToGrant = [p];
        var grantVar = server.GrantItemsToUser(
          {
            CatalogVersion : "CarCards",
            PlayFabId: currentPlayerId,
            ItemIds : itemsToGrant
          }
        );

        itemData = {"Amount" : args.carCardsRequest[p]};
        server.UpdateUserInventoryItemCustomData(
          {
            PlayFabId: currentPlayerId,
            ItemInstanceId: grantVar.ItemGrantResults[0].ItemInstanceId,
            Data: itemData
          }
        );
      }
    }
  }
  //part cards
  for(var p in args.partCardsRequest)
  {
    //log.debug(p + " : " + args.partCardsRequest[p]);
    if (args.partCardsRequest.hasOwnProperty(p))
    {
      itemFound = false;
      newAmount = 0;
      // log.debug("looking for: " +p);
      for(var i = 0; i < userInventoryObject.Inventory.length; i++)
      {
        if((userInventoryObject.Inventory[i].ItemId == p) && (userInventoryObject.Inventory[i].CatalogVersion == "PartCards"))
        {
          // log.debug("adding amount to: " + userInventoryObject.Inventory[i].ItemInstanceId);
          if(userInventoryObject.Inventory[i].CustomData == undefined)
          {
            newAmount = Number(args.partCardsRequest[p]);
          }
          else
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount == undefined)
            newAmount = Number(args.partCardsRequest[p]);
            else
            {
              if(isNaN(Number(userInventoryObject.Inventory[i].CustomData.Amount)))
              newAmount = Number(args.partCardsRequest[p]);
              else
              newAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + Number(args.partCardsRequest[p]);
            }
          }
          itemData = {"Amount" : newAmount};
          server.UpdateUserInventoryItemCustomData(
            {
              PlayFabId: currentPlayerId,
              ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
              Data: itemData
            }
          );
          itemFound = true;
          break;
        }
      }
      if(itemFound == false)
      {
        var itemsToGrant = [p];
        var grantVar = server.GrantItemsToUser(
          {
            CatalogVersion : "PartCards",
            PlayFabId: currentPlayerId,
            ItemIds : itemsToGrant
          }
        );

        itemData = {"Amount" : args.partCardsRequest[p]};
        server.UpdateUserInventoryItemCustomData(
          {
            PlayFabId: currentPlayerId,
            ItemInstanceId: grantVar.ItemGrantResults[0].ItemInstanceId,
            Data: itemData
          }
        );
      }
    }
  }

  var outInventory =   server.GetUserInventory({PlayFabId: currentPlayerId});

  //give experience for opening chest unless this chest was opened as part of leveling up reward:
  //if no chest id is provided, it means that this function is used for inventory update
  if((args.chestId) && (args.isLevelUp != true)){
    var totalXp = UpdateExperience("Chests", args.chestId, "xpGain", 0, true);
      outInventory.Experience = totalXp;
  }

  return generateInventoryChange("InventoryUpdated", outInventory);
};
handlers.purchaseBMItem = function(args, context)
{
  //log.debug("purchasing item " + args.itemId + " from black market");
  if((args.itemId < 0) || (args.itemId > 3)) return generateFailObj("invalid item index");
  var keysToGet = [];
  keysToGet.push("BMItem" + args.itemId);

  var getInternalDataResult = server.GetUserInternalData(
  {
    PlayFabId: currentPlayerId,
    Keys: keysToGet
  }
  );

  var userInventoryObject = server.GetUserInventory(
  {
    PlayFabId: currentPlayerId
  }
  );

  var userArray = getInternalDataResult.Data["BMItem" + args.itemId].Value.split("_");//name, curr, baseCost, uses, costUse
  //log.debug("userArray: " + userArray);
  var playerMoney = userInventoryObject.VirtualCurrency[userArray[1]];

  if(userArray.length != 5)
  {
    generateErrObj("User Black Market corrupted. Try again tomorrow");
  }

  var catalogName = "";
  if(args.itemId < 2)
    catalogName = "PartCards";
  else
    catalogName = "CarCards";

  var price = parseInt(userArray[2]) + parseInt(userArray[3])* parseInt(userArray[4]);
  var checkObj = checkBalance(userArray[1], price, playerMoney, playerMoney);
  if(checkObj != "OK") return checkObj;
  //try
  //{
    var cardInstance;
    var cardAmount = 0;
    var cardData;
   // log.debug("searching for: " + userArray[0] + " in " + catalogName);
    for(var i = 0; i < userInventoryObject.Inventory.length; i++) // if we find it in the inventory we just give him the amount of cards we owe the player
    {
      if((userInventoryObject.Inventory[i].ItemId == userArray[0]) && (userInventoryObject.Inventory[i].CatalogVersion == catalogName))
      {
       // log.debug("found it!");
        cardInstance = userInventoryObject.Inventory[i].ItemInstanceId;
        if(userInventoryObject.Inventory[i].CustomData === undefined)
        {
         // log.debug("no custom data. creating ...");
          cardData = {"Amount" : 1};
        }
        else
        {
          if(userInventoryObject.Inventory[i].CustomData.Amount === undefined)
            cardData = {"Amount" : 1};
          else
          {
          var tempAmount = Number(userInventoryObject.Inventory[i].CustomData.Amount) + 1;
          if(isNaN(tempAmount)) tempAmount = 1;
          cardData = {"Amount" : tempAmount};
          }
        }

        server.UpdateUserInventoryItemCustomData(
              {
                PlayFabId: currentPlayerId,
                ItemInstanceId: cardInstance,
                Data: cardData
              }
              );

        break;
      }
    }
    if(cardInstance === undefined)
    {
      //log.debug("cardInstance is undefined");
      var itemsToGive = [];
      itemsToGive.push(userArray[0]);
      var grantRequest = server.GrantItemsToUser(
        {
          CatalogVersion : catalogName,
          PlayFabId: currentPlayerId,
          ItemIds : itemsToGive
        }
        );
      cardInstance = grantRequest.ItemGrantResults[0].ItemInstanceId;
      if(cardInstance === undefined)
        generateErrObj("grantRequest denied");
      else
      {
        cardData = {"Amount" : 1};
        server.UpdateUserInventoryItemCustomData(
          {
            PlayFabId: currentPlayerId,
            ItemInstanceId: cardInstance,
            Data: cardData
          }
          );
      }
    }
    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : userArray[1],
        Amount: price
      }
      );
    var itemVal = userArray[0] + "_" + userArray[1] + "_" + userArray[2] + "_"  + (parseInt(userArray[3]) + 1) + "_" +  userArray[4];
    //log.debug("generatedArray: " + itemVal);
    var dataToUpdate = {};
    dataToUpdate["BMItem" + args.itemId] = itemVal;
    server.UpdateUserInternalData(
      {
        PlayFabId : currentPlayerId,
        Data : dataToUpdate
      }  );
    var objectsUpdated =
        [
        {
          ItemId : userArray[0],
          CatalogVersion: catalogName,
          CustomData: cardData
        }
        ];

      var currencyUpdated = {};
      currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
      var b=args.itemId+"_"+userArray[2]+"_"+(parseInt(userArray[3]) + 1)+"_"+userArray[4];
      i={
            Inventory: objectsUpdated,
            VirtualCurrency: currencyUpdated
        };
      var returnObj = {
        Result: "OK",
        Message: "InventoryUpdate",
        InventoryChange:i,
        BMItemChange: b
      };
      return returnObj;
};
handlers.purchaseItems = function(args, context)
{
  //retrieve user inventory
  //log.debug("RETRIEVING USER INVENTORY");
  var userInventoryObject = server.GetUserInventory(
    {
      PlayFabId: currentPlayerId
    }
  );
  //retrieve player currency
  var playerSC = userInventoryObject.VirtualCurrency.SC;
  var playerHC = userInventoryObject.VirtualCurrency.HC;

  //log.debug("user currency: SC: " + playerSC + " HC: " + playerHC);

  switch(args.purchaseType)
  {
    case "carUpgrade":
      return upgradeCar(args, userInventoryObject, playerSC, playerHC);

    case "partUpgrade":
      return upgradePart(args, userInventoryObject, playerSC, playerHC);

    case "custPurchase":
    // log.debug("Purchasing Customization: " + args.custId + " with val: " + args.custVal);
    var custCatalog = server.GetCatalogItems(
      {
        CatalogVersion : "Customization"
      }
    );

    var custCatalogItem;
    var custPrice = 0;
    var custCurr = "SC";
    for(var i = 0; i < custCatalog.Catalog.length; i++)
    {
      if(custCatalog.Catalog[i].ItemId == args.custId)
      {
        custCatalogItem = custCatalog.Catalog[i];
        cardInfo = JSON.parse(custCatalog.Catalog[i].CustomData)
        var keyRequestCurr = args.custVal + ",Curr";
        var keyRequestCost = args.custVal + ",Cost";

        custCurr = cardInfo[keyRequestCurr];
        custPrice = cardInfo[keyRequestCost];

        var costCheckObj = checkBalance(custCurr, custPrice, playerSC, playerHC);
        if(costCheckObj != "OK") return costCheckObj;

        // log.debug("custCurr: " + custCurr);
        //   log.debug("custPrice: " + custPrice);

        break;
      }
    }

    if(custCatalogItem == undefined)
    return generateErrObj("Customization does not exist in catalog.");

    //  log.debug("Checking to see if user has said customization");
    var customizationItem;
    var customizationItemInstance;
    for(var i = 0; i < userInventoryObject.Inventory.length; i++)
    {
      if(userInventoryObject.Inventory[i].ItemId == args.custId)
      {
        //       log.debug("user has customization category!");
        customizationItem = userInventoryObject.Inventory[i];
        customizationItemInstance = userInventoryObject.Inventory[i].ItemInstanceId;
        if (customizationItem.CustomData != undefined)
        {
          if (String(args.custVal) in customizationItem.CustomData)
          {
            return generateFailObj("User already has this customization.");
          }
        }
        break;
      }
    }

    if(customizationItem == undefined)
    {
      log.info("user doesn't have customization category. Granting ... ");
      var itemsToGive = [];
      itemsToGive.push(args.custId);

      var custToGive = server.GrantItemsToUser(
        {
          CatalogVersion : "Customization",
          PlayFabId: currentPlayerId,
          ItemIds : itemsToGive
        }
      );

      if(custToGive.ItemGrantResults[0].Result == false)
      return generateErrObj("something went wrong while granting user customization class object.");

      customizationItemInstance = custToGive.ItemGrantResults[0].ItemInstanceId;
    }

    var customizationData = {};
    customizationData[String(args.custVal)] = "Owned";

    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: customizationItemInstance,
        Data: customizationData
      }
    );
    var i;
    var objectsUpdated =
    [
      {
        ItemId : args.custId,
        CatalogVersion: "Customization",
        CustomData : customizationData
      }
    ];

    if(custPrice > 0)
    {
      var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
        {
          PlayFabId: currentPlayerId,
          VirtualCurrency : custCurr,
          Amount: custPrice
        }
      );

      var currencyUpdated = {};
      currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
      i =
      {
        Inventory: objectsUpdated,
        VirtualCurrency: currencyUpdated
      };
    }
    else
    {
      i =
      {
        Inventory: objectsUpdated
      };
    }
    return generateInventoryChange("InventoryUpdateNewCustomization", i)

    break; // big switch
    case "softCurrencyPurchase":
    //   log.debug("Purchasing pack: " + args.packId);

    //   log.debug("Checking to see if pack exists in catalog");
    var packCatalog = server.GetCatalogItems(
      {
        CatalogVersion : "SoftCurrencyStore"
      }
    );

    var packExists = false;
    var packPrice = 0;
    for(var i = 0; i < packCatalog.Catalog.length; i++)
    {
      if(packCatalog.Catalog[i].ItemId == args.packId)
      {
        packPrice = packCatalog.Catalog[i].VirtualCurrencyPrices.HC;
        cardInfo = JSON.parse(packCatalog.Catalog[i].CustomData);
        packExists = true;
        break;
      }
    }

    if(packExists == false)
    return generateErrObj("pack with ID: " + args.packId + " not found in catalog.");

    if(packPrice <= 0)
    return generateErrObj("pack with ID: " + args.packId + " shouldn't have negative cost.");

    if(packPrice > playerHC)
    return generateFailObj("Not enough HC.");

    var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : "HC",
        Amount: packPrice
      }
    );

    var addUserCurrencyResult = server.AddUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : "SC",
        Amount: cardInfo.quantity
      }
    );
    var currencyUpdated = {};
    currencyUpdated[addUserCurrencyResult.VirtualCurrency] = addUserCurrencyResult.Balance;
    currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
    var invChangeObj =
    {
      VirtualCurrency: currencyUpdated
    };
    return generateInventoryChange("SoftCurrencyPurchased", invChangeObj)
    break;

    default:
    log.debug("invalid purchase parameter");
  }
};
handlers.requestCurrency = function(args)
{
  var userInventoryObject = server.GetUserInventory(
  {
    PlayFabId: currentPlayerId,
  }
  );
  var r =
  {
    VirtualCurrency: userInventoryObject.VirtualCurrency
  };
  return r;
};
handlers.requestInventory = function(args)
{
  var userInventoryObject = server.GetUserInventory(
  {
    PlayFabId: currentPlayerId,
  }
  );
  //get catalog data for pr calculation
    var carCardsCatalog = server.GetCatalogItems(
         {
           CatalogVersion : "CarCards"
         }
         );
    var partCardsCatalog = server.GetCatalogItems(
       {
         CatalogVersion : "PartCards"
       }
       );
  var hasCars = false;
  for(var i = 0; i < userInventoryObject.Inventory.length; i++)
  {
    if(userInventoryObject.Inventory[i].CatalogVersion == "CarsProgress")
    {
      hasCars = true;
      var check = checkCarDataValidity(userInventoryObject.Inventory[i], carCardsCatalog);
      //log.debug("check " + check);
      if((check == "PlayFabError") || (check === undefined)) return generateErrObj("PlayfabError");
      else if(check == "OK") log.debug("Data for " + userInventoryObject.Inventory[i].ItemId + " OK");
           else userInventoryObject.Inventory[i].CustomData = check;
      userInventoryObject.Inventory[i].CustomData.Pr = recalculateCarPr(userInventoryObject.Inventory[i].CustomData, userInventoryObject.Inventory[i].ItemId, carCardsCatalog, partCardsCatalog);
      var d = {};
      d["Pr"] = userInventoryObject.Inventory[i].CustomData.Pr;
      server.UpdateUserInventoryItemCustomData( // if this doesn't happen it's still fine; we might actually be able to skip this entirely
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
        Data: d
      }
      );
    }
  }
  if(hasCars === false)
    {
      var carsToGive = [];
      carsToGive.push("FordFocus");
      var carRequest = server.GrantItemsToUser(
      {
        CatalogVersion : "CarsProgress",
        PlayFabId: currentPlayerId,
        ItemIds : carsToGive
      }
      );
      var CarData = {"CarLvl" : "1","EngineLvl" : "0","ExhaustLvl" : "0","GearboxLvl" : "0","SuspensionLvl" : "0"};
      server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
      );
      CarData = {"TiresLvl" : "0","TurboLvl" : "0","PaintId" : "0","DecalId" : "0","RimsId" : "0"};
      server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
      );
      CarData = {"PlatesId" : "0","WindshieldId" : "0","Pr" : "10"};
      server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carRequest.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
      );
      return generateErrObj("UserHasNoCars ... reiniting");
    }
  return userInventoryObject;
};
handlers.retrieveBlackMarket = function(args, context)
{
  //let's get last BM Time Call
  var keysToGet = [];
  keysToGet.push("BMTime");
  for(var i = 0; i < 4; i++)
  {
    keysToGet.push("BMItem" + i);
  }

  var getInternalDataResult = server.GetUserInternalData(
    {
      PlayFabId: currentPlayerId,
      Keys: keysToGet
    }
    );

  if(getInternalDataResult.Data.BMTime === undefined)
  {
    //log.debug("No user BM data detected; generating ...");
    return GenerateBlackMarket(currentPlayerId);
  }

  var d = new Date();
  //log.debug("milliseconds passed: " +  d.getTime());
  //log.debug("BMTime: " +  getInternalDataResult.Data.BMTime.Value);

  var tK = [];
  tK.push("BlackMarketResetMinutes");
  var tData = server.GetTitleData(
    {
      PlayFabId : currentPlayerId,
      Keys : tK
    }
    );
  if(args.reset === true)
  {
    //log.debug("reseting market");
    var curr = "HC";
    var cost = 200;
    var td = server.GetTitleData(
    {
      Keys : ["BlackMarketResetCost"]
    });
    if(td.Data["BlackMarketResetCost"] !== undefined)
    {
      var tDatArr = td.Data["BlackMarketResetCost"].split("_");
      curr = tDatArr[0];
      cost = Number(tDatArr[1]);
    }

    if(cost > 0)
    {
      var userInventoryObject = server.GetUserInventory(
      {
        PlayFabId: currentPlayerId
      }
      );

      var bO = checkBalance(curr, cost, userInventoryObject.VirtualCurrency.SC, userInventoryObject.VirtualCurrency.HC);
      if(bO != "OK") return generateFailObj("not enough money");

      var subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
        {
          PlayFabId: currentPlayerId,
          VirtualCurrency : curr,
          Amount: cost
        }
        );
      var marketObject = GenerateBlackMarket(currentPlayerId);
      ////////////////
      var currencyUpdated = {};
      currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
      i =
         {
           VirtualCurrency: currencyUpdated
         };
      marketObject["InventoryChange"] = i;
      return marketObject;
      ////////////////
    }
    return GenerateBlackMarket(currentPlayerId);
  }

  if(d.getTime() - parseInt(getInternalDataResult.Data.BMTime.Value) > parseInt(tData.Data.BlackMarketResetMinutes) *60*1000) // minutes *60*1000
  {
    //log.debug("regenerating market");
    return GenerateBlackMarket(currentPlayerId);
  }
  //log.debug("get current market");
  return GetCurrentBlackMarket(currentPlayerId, getInternalDataResult);
};
handlers.startGame = function(args, context) {
  //let's see what subleague we are in and what win/loss ration we have
  //wlratio
  var wlStat = "10"; // 50/50 for newtimers
  var wlStatInt = 0; // we change the bitwise representation to int32 and store it like that
  var winRatio = 50;
  var totalGames = 2;
  var wins = 0;
  var ps=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["WinLoss"]
  });
  if(ps.Statistics.length != 0)
  {
      wlStatInt = ps.Statistics[0].Value.toString();
      wlStat = Number(wlStatInt).toString(2);
      totalGames = wlStat.length;
      for(var i = 0; i < wlStat.length; i++)
      {
        if(wlStat[i] == "1") wins++;
      }
      winRatio = Math.round( 100* (wins/totalGames));
  }
  //start game so we assume it'sa lose until it's a win
  //log.debug("wlStatBeforeshiftandAdd " + wlStat);
  wlStat += "0";
  //log.debug("wlStatBeforeshift " + wlStat);
   if(wlStat.length > 20)
   {
    wlStat = wlStat.slice(1);
   }
  // log.debug("wlStat " + wlStat);
  //trophy count and subleague distribution
  var leagueTitleDataRequest = server.GetTitleData(
    {
      Key: ["LeagueSubdivisions","SubdivisionTrophyRanges","TrophyGainRange","TrophyLoseRange"]
    }
    );
  var tc=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["TrophyCount"]
  });
  var trophyCount = 0;
  if(tc.Statistics.length != 0)
  {
    trophyCount = tc.Statistics[0].Value;
  }
  trophyCount = Number(trophyCount);
  var sdval = leagueTitleDataRequest.Data["SubdivisionTrophyRanges"];
  var sdvalParsed = JSON.parse(sdval);
  var lsVal = leagueTitleDataRequest.Data["LeagueSubdivisions"];
  var lsValParsed = JSON.parse(lsVal);
  //log.debug("SubdivisionTrophyRanges " + sdvalParsed);
  var subDivision = 43;
  var nextSubDivision = 43;
  var subDivisionRange = 200;
          var rminmaxarr = leagueTitleDataRequest.Data["TrophyGainRange"].split("_");
          var lminmaxarr = leagueTitleDataRequest.Data["TrophyLoseRange"].split("_");
          var rMin = Number(rminmaxarr[0]);
          var rMax = Number(rminmaxarr[1]);
          var lMin = Number(lminmaxarr[0]);
          var lMax = Number(lminmaxarr[1]);
  for(var i = 0; i < sdvalParsed.subdivisions.length; i++)
  {
    if(trophyCount<Number(sdvalParsed.subdivisions[i]))
    {
      subDivision = i;
      if(i < sdvalParsed.subdivisions.length - 1) nextSubDivision = i + 1;
      break;
    }
  }
  subDivisionRange = Number(sdvalParsed.subdivisions[nextSubDivision]) - Number(sdvalParsed.subdivisions[subDivision]);
  log.debug("nextSubDivision " + nextSubDivision + " subDivision " + subDivision);
  log.debug(" sdvalParsed.subdivisions[nextSubDivision] " + sdvalParsed.subdivisions[nextSubDivision] + " sdvalParsed.subdivisions[subDivision] " + sdvalParsed.subdivisions[subDivision]);
  if(subDivisionRange <= 0) subDivisionRange = 400; // random 400
  log.debug("subDivisionRange " + subDivisionRange);
  //log.debug("user is in subdivision " + subDivision);

  //matchmaking code
  //let's get subdivision and neighbouring subdivisions
  var subDivKeys = ["RecSubDivision"+subDivision];
  var titleData = server.GetTitleInternalData(
    {
      Keys : "RecSubDivision"+subDivision
    }
    );
  var recPool = titleData.Data["RecSubDivision"+subDivision];
  var isIncompleteSubDivision = false;
  //log.debug("recPool " + recPool);
  if(recPool == undefined) isIncompleteSubDivision = true;
  var recArray;
  var opponentId;
  var env;
  var course;

//previous opponents
var oppPrev = "noop"; // ultimu
var oppPrevPrev = "noop";// penultimu
var oppArray;
var oppDat = server.GetUserInternalData(
{
    PlayFabId: currentPlayerId,
    Keys: ["lastOpp"]
});

if((oppDat.Data == undefined) || (oppDat.Data.lastOpp == undefined))
{
  //log.debug("opp data is undefined");
  oppPrev = "noop";
  oppPrevPrev = "noop";
}
else
{
  oppArray = oppDat.Data.lastOpp.Value.split(",");
 // log.debug("oppArray is " + oppArray);
  for(var i = 0; i < oppArray.length; i++)
  {
    if(i == 0) oppPrev = oppArray[i];
    if(i == 1) oppPrevPrev = oppArray[i];
  }
 // log.debug("oppPrev is " + oppPrev);
 // log.debug("oppPrevPrev is " + oppPrevPrev);
}
  if(isIncompleteSubDivision == false)
  {
    recArray = JSON.parse(recPool);
    opponentId = recArray[recArray.length - 1].uId;
    env = recArray[recArray.length - 1].e;
    course = recArray[recArray.length - 1].c;
  }
  else
  {
    recArray = [];
  }

  //default recording code
  var subDivisionLength = 15; // we have 15 possible courses
  var envCourseArray =
  [
  0,0,0,0,0,
  0,0,0,0,0,
  0,0,0,0,0
  ]
  //log.debug("subrecording pool has " + recArray.length + " length. Must have: " + subDivisionLength + " length");

  if(recArray.length < subDivisionLength) isIncompleteSubDivision = true;

  var validRecArray = new Array(recArray.length); // all recordings except yours
  var vrAidx = 0;
  var likelyRecArray = new Array(recArray.length); // all recordings minus yours AND minus oppPrev
  var lrAidx = 0;
  var moreLikelyRecArray = new Array(recArray.length); // all recordings minus yours AND minus oppPrev AND minus oppPrevPrev
  var mlrAidx = 0;
  //log.debug("iterating through recArray");
  for(var i = 0; i < recArray.length; i++) // create valid rec pool OR check for missing env/course if subDivision has missing recordings
  {
      if(isIncompleteSubDivision == true)
      {
        envCourseArray[Number(recArray[i].e)*5 + Number(recArray[i].c)] = 1;
      }
      if(recArray[i].uId == currentPlayerId)
        {
         // log.debug("found: " + recArray[i].uId + "... skipping");
          continue;
        }
        validRecArray[vrAidx] = recArray[i];
        vrAidx++;
      if(recArray[i].uId == oppPrev)
        {
         // log.debug("found: " + recArray[i].uId + "... skipping prev opp");
          continue;
        }
        likelyRecArray[lrAidx] = recArray[i];
        lrAidx++;
      if(recArray[i].uId == oppPrevPrev)
        {
         // log.debug("found: " + recArray[i].uId + "... skipping prev prev opp");
          continue;
        }
        moreLikelyRecArray[mlrAidx] = recArray[i];
        mlrAidx++;
  }
//log.debug("isIncompleteSubDivision: " + isIncompleteSubDivision);
//let's give default recording if necessary
if(isIncompleteSubDivision == true)
{
  var envToGet = 0;
  var courseToGet = 0;
  for(var i = 0; i < envCourseArray.length; i++)
  {
    if(envCourseArray[i] == 0)// we found a missing recording <- e = i/5; c = i%5;
    {
      envToGet = Math.floor(i/5);
      courseToGet = i%5;
      break;
    }
  }
  //log.debug("gettingDefaultUser: env: " + envToGet + " course: " + courseToGet);
  //let's see who the master account is
    var masterAccountRequest = server.GetTitleData(
    {
      Keys : "MasterUser"
    }
    );
    if(masterAccountRequest.Data["MasterUser"] != undefined)
    {
     // log.debug("master user: " + masterAccountRequest.Data["MasterUser"]);
      var defaultRecordingData = server.GetUserReadOnlyData(
      {
        PlayFabId: masterAccountRequest.Data["MasterUser"],
        Keys: [(envToGet + "_" + courseToGet + "_RecPos") , (envToGet + "_" + courseToGet + "_RecRot"), (envToGet + "_" + courseToGet + "_RecHeader")]
      }
      );
      if(defaultRecordingData.Data != undefined)
      {
        //log.debug("defaultRecordingData: " + defaultRecordingData.Data);
        if((defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecPos"] != undefined) && (defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecRot"] != undefined) && (defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecHeader"] != undefined))
        { // looks like we found a valid default recording
          var updateTrophyInternal = true;
          if(trophyCount == 0)
          {
            trophyCount = rMax;
            updateTrophyInternal = false;
          }
          else
          {
            trophyCount -= lMin;
          }
          if(trophyCount <= 1) trophyCount = 1;
          wlStatInt = parseInt(wlStat, 2);
          //log.debug("updating WL to:  " + wlStatInt);
          //update stats on server
          var suArray = [];
          var su = {StatisticName: "WinLoss", Version : "0", Value: wlStatInt};
          suArray.push(su);
          var sut = {StatisticName: "TrophyCount", Version : "0", Value: trophyCount};
          suArray.push(sut);
          var sul = {StatisticName: "League", Version : "0", Value: cLeague};
          suArray.push(sul);
          //log.debug("updatingStats: " + suArray);
          var updateRequest = server.UpdatePlayerStatistics(
          {
            PlayFabId: currentPlayerId,
            Statistics: suArray
          }
          );
          var dataToUpdate = {
            "trophyWin" : rMax,
            "trophyLose": lMin
          }
          if(updateTrophyInternal == false)
          {
            dataToUpdate["trophyWin"] = 0;
            dataToUpdate["trophyLose"] = 0;
          }
          server.UpdateUserInternalData(
          {
            PlayFabId: currentPlayerId,
            Data: dataToUpdate
          });
          //log.debug("found valid default rec");
          return {
            Result :"OK",
            RecType: "Default",
            PosData: defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecPos"].Value, //0_0_RecPos
            RotData: defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecRot"].Value,
            HeaderData: defaultRecordingData.Data[envToGet + "_" + courseToGet + "_RecHeader"].Value,
            TrophyLose: lMin,
            TrophyWin : rMax,
            Opp: "Mniezo"
                 };
        }
      }
    }
}
//log.debug("looking for user generated recording");
if(vrAidx == 0) return generateErrObj("no valid recording found for this subdivision");

//we have 3 arrays. We want the likelyhood that you get the same previous opponents to be as low as possible
//so we will see if moreLikelyRecArray is empty. If yes we check if likelyRecArray is empty.
//if they are both empty we remain with the current validRecArray array
var searchArray = validRecArray;
var sAlen = vrAidx;
  if(lrAidx > 0){sAlen = lrAidx; searchArray = likelyRecArray}
  if(mlrAidx > 0){sAlen = mlrAidx; searchArray = moreLikelyRecArray}

  var pivot = sAlen - 1; //in case your WLRatio is the highest in the pool
  for(var i = 0; i < sAlen; i++) // write winstreak/losestreak code
  {
    if(searchArray[i].wl > winRatio) //let's find the pivot; we'll move it later based on WL ratio
    {
      pivot = i;
      break;
      //opponentId = recArray[i].uId;
      //env = recArray[i].e;
      //course = recArray[i].c;
    }
  }
 // log.debug("pivot is: " + pivot);
  var finalRecArraySize = Math.min(sAlen, 3); // for now 3 is the max number of recordings in the random final pool
 // log.debug("finalRecArraySize: " + finalRecArraySize);
  var finalRecArray = new Array(finalRecArraySize); // this array will be populated with the recordings around the pivot
  for(var i = 0; i < finalRecArraySize; i++)
  {
    if(pivot <= 0) // get rightmost recordings
    {
      finalRecArray[i] = searchArray[i];
      continue;
    }
    if(pivot >= sAlen - 1) // get leftmost recordings
    {
      finalRecArray[i] = searchArray[sAlen - 1 - i];
      continue;
    }
    finalRecArray[i] = searchArray[(pivot - Math.floor(finalRecArraySize/2) + i)]; // get inner recordings
  }
  var randIdx = Math.floor(Math.random() * finalRecArraySize); // let's get a random one from this final pool
    opponentId = finalRecArray[randIdx].uId;
    env = finalRecArray[randIdx].e;
    course = finalRecArray[randIdx].c;
  var urodkr = [(env + "_" + course + "_RecPos") , (env + "_" + course + "_RecRot"), (env + "_" + course + "_RecHeader")];
 // log.debug("requesting " + urodkr);
  var recordingData = server.GetUserReadOnlyData(
    {
      PlayFabId: opponentId,
      Keys: urodkr
    }
    );
  if(recordingData == undefined) return generateErrObj("Did not find recording for this user: " + opponentId); // handle this later
  //end matchmaking

  var oI = server.GetPlayerCombinedInfo(
    {
      PlayFabId:opponentId,
      InfoRequestParameters: {"GetUserAccountInfo": true,"GetUserInventory": false,"GetUserVirtualCurrency": false,"GetUserData": false,"GetUserReadOnlyData": false,"GetCharacterInventories": false,"GetCharacterList": false, "GetTitleData": false,"GetPlayerStatistics": false}
    }
    );
  //found recording now let's reduce user's trophies
          //let's extract opponent trophies so we know how muany trophies we give/takeaway from user
          var trophiesToTake = 15; // min
          var trophiesToGive = 30; // max
          var userTrophies = trophyCount;
          var oppTrophies;
          var cLeague = Number(calculateLeague(trophyCount));
          var recTypeSent = "UserGenerated";
//log.debug("cLeague " + cLeague);
  //        log.debug("lsValParsed: " + lsValParsed);
  //        log.debug("sdvalParsed: " + sdvalParsed);
  //        log.debug("lsValParsed.leagues: " + lsValParsed.leagues);
  //        log.debug("sdvalParsed.subDivisions: " + sdvalParsed.subdivisions);

          var minLeagueT
          if(cLeague > 0)
            minLeagueT = Number(sdvalParsed.subdivisions[lsValParsed.leagues[cLeague - 1]]);
          else
            minLeagueT = 0;

          var maxLeagueT;
          if(cLeague >= lsValParsed.leagues.length - 1)
            maxLeagueT = minLeagueT * 2;
          else
            maxLeagueT = Number(sdvalParsed.subdivisions[lsValParsed.leagues[cLeague]]);

//log.debug("maxLT " + maxLeagueT + " minLeagueT " + minLeagueT);

          var opponentHeader = JSON.parse(recordingData.Data[env + "_" + course + "_RecHeader"].Value);
          if(opponentHeader != undefined)
          {
            oppTrophies = opponentHeader.Trophies;
          }
          oppTrophies = Number(oppTrophies);
          if(maxLeagueT - minLeagueT <= 0)
          {
              trophiesToTake = rMax;
              trophiesToGive = lMin;
          }
          else
          {
            if(Number(Math.abs(userTrophies - oppTrophies)) > Number(subDivisionRange))
            {
              trophiesToTake = Math.floor((lMin + lMax)/2);
              trophiesToGive = Math.floor((rMax + rMin)/2);
              recTypeSent = "Default";
            }
            else
            {
            //  log.debug("rMin: " + rMin + " userTrophies: " + userTrophies + " oppTrophies " + oppTrophies + " maxLeagueT " + maxLeagueT + " minLeagueT " + minLeagueT + " rMax: " + rMax);
              trophiesToTake = lMin + Math.floor((((userTrophies - oppTrophies)/(maxLeagueT - minLeagueT)) + 1) * ((lMax - lMin)/2));
              trophiesToGive = rMin + Math.floor((((oppTrophies - userTrophies)/(maxLeagueT - minLeagueT)) + 1) * ((rMax - rMin)/2));
            }
          }

  var updateTrophiesToGiveTake = true;
  if(trophyCount == 0)
  {
    updateTrophiesToGiveTake = false;
    trophyCount = rMax;
  }
  else
  {
    trophyCount -= Number(trophiesToTake);
    if(trophyCount <= 1) trophyCount = 1;
  }
  //log.debug("trophiesToTake:  " + trophiesToTake);
 // log.debug("trophiesToGive:  " + trophiesToGive);
  wlStatInt = parseInt(wlStat, 2);
 // log.debug("updating WL to:  " + wlStatInt);
  //update stats on server
  var suArray = [];
  var su = {StatisticName: "WinLoss", Version : "0", Value: wlStatInt};
  suArray.push(su);
  var sut = {StatisticName: "TrophyCount", Version : "0", Value: trophyCount};
  suArray.push(sut);
  var sul = {StatisticName: "League", Version : "0", Value: cLeague};
  suArray.push(sul);
 // log.debug("updatingStats: " + suArray);
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: suArray
  }
  );
  var lastOppVal = opponentId + "," + oppPrev;
            var dataToUpdate = {
            "trophyWin" : trophiesToGive,
            "trophyLose": trophiesToTake,
            "lastOpp" : lastOppVal
          }
  if(updateTrophiesToGiveTake == false)
  {
          dataToUpdate["trophyWin"] = 0;
          dataToUpdate["trophyLose"] = 0;
  }
          server.UpdateUserInternalData(
          {
            PlayFabId: currentPlayerId,
            Data: dataToUpdate
          });


  return {
    Result :"OK",
    RecType: recTypeSent,
    PosData: recordingData.Data[env + "_" + course + "_RecPos"].Value, //0_0_RecPos
    RotData: recordingData.Data[env + "_" + course + "_RecRot"].Value,
    HeaderData: recordingData.Data[env + "_" + course + "_RecHeader"].Value,
    TrophyLose: trophiesToTake,
    TrophyWin : trophiesToGive,
    Opp: oI.InfoResultPayload.AccountInfo.TitleInfo.DisplayName
         };
}
handlers.updateCarCust = function(args, context)
{
  var userInv = server.GetUserInventory(
  {
    PlayFabId : currentPlayerId,
  }
  );
  var itemsToGive = [];
  var carFound = "-1";
  var DataToUpdate = {};
  var customizations = {
    PaintJobs : { itemOwned : "no", itemCustData: args.paintId, carItemId : "PaintId" },
    Decals : { itemOwned : "no", itemCustData: args.decalId, carItemId : "DecalId" },
    Plates : { itemOwned : "no", itemCustData: args.platesId, carItemId : "PlatesId" },
    Rims : { itemOwned : "no", itemCustData: args.rimsId, carItemId : "RimsId" },
    WindshieldText : { itemOwned : "no", itemCustData: args.wsId, carItemId : "WindshieldId" }
  };

  for(var i = 0; i < userInv.Inventory.length; i++)
  {
    if((userInv.Inventory[i].ItemId == args.carId) && (userInv.Inventory[i].CatalogVersion == "CarsProgress"))
    {
      carFound = userInv.Inventory[i].ItemInstanceId;
    }
    if(userInv.Inventory[i].ItemId in customizations)
    {
      customizations[userInv.Inventory[i].ItemId].itemOwned = "yes";
      if(customizations[userInv.Inventory[i].ItemId].itemCustData in userInv.Inventory[i].CustomData)
      {
        DataToUpdate[customizations[userInv.Inventory[i].ItemId].carItemId] = customizations[userInv.Inventory[i].ItemId].itemCustData;
      }
      else
      {
        log.debug("user doesn't own: " + userInv.Inventory[i].ItemId + " " + customizations[userInv.Inventory[i].ItemId].itemCustData);
      }
    }
  }
  if(carFound == "-1")
  {
    return generateFailObj("User does not own car with id: " + args.carId);
  }
    //give inventory
  for (var prop in customizations)
  {
    if (customizations.hasOwnProperty(prop))
    {
        if(customizations[prop].itemOwned == "no")
        {
           itemsToGive.push(prop);
        }
    }
  }

  if(DataToUpdate == {}) return generateFailObj("User doesn't own any of those customizations");
  server.UpdateUserInventoryItemCustomData(
     {
       PlayFabId: currentPlayerId,
       ItemInstanceId: carFound,
       Data: DataToUpdate
     }
     );
  var objectsUpdated =
  [
  {
    ItemId : args.carId,
    CatalogVersion: "CarsProgress",
    CustomData : DataToUpdate
  }
  ];
  if(itemsToGive.length > 0)
  {
    var grantRequest = server.GrantItemsToUser(
    {
      CatalogVersion : "Customization",
      PlayFabId: currentPlayerId,
      ItemIds : itemsToGive
    }
    );

    var InvData = {
      0 : "Owned"
    };

   for(var i = 0; i < grantRequest.ItemGrantResults.length; i++)
  {
    server.UpdateUserInventoryItemCustomData(
         {
           PlayFabId: currentPlayerId,
           ItemInstanceId: grantRequest.ItemGrantResults[i].ItemInstanceId,
           Data: InvData
         }
         );
  }
  }
  var invChangeObj =
      {
          Inventory: objectsUpdated
      };
  var returnObj = {
    Result: "OK",
    Message: "InventoryUpdate",
    InventoryChange:invChangeObj
  };
  return returnObj;

};
// matchmaking code
handlers.updateTrophyCount = function(args, context) {
  var t = 0;
  var ps=server.GetPlayerStatistics(
  {
     PlayFabId: currentPlayerId,
     StatisticNames: ["TrophyCount"]
  });
  if(ps.Statistics.length !== 0)
  {
    t = ps.Statistics[0].Value;
  }
  if(args.val == "rStart") t-=30;
  if(t < 0) t=0;
  if(args.val == "rWin") t+=60;
  if(args.val == "rLose") return {val:t};
  var suArray = [];
  var su = {StatisticName : "TrophyCount", Version : "0", Value: t};
  suArray.push(su);
  var updateRequest = server.UpdatePlayerStatistics(
  {
    PlayFabId: currentPlayerId,
    Statistics: suArray
  }
  );
  if(args.val == "rWin") return {val:t};
};
function upgradeCar(args, userInventoryObject, playerSC, playerHC)
{
  var carCardsCatalog = server.GetCatalogItems(
    {
      CatalogVersion : "CarCards"
    }
  );

  var carFound = false;
  var car;
  for(var i = 0; i < userInventoryObject.Inventory.length; i++)
  {
    if((userInventoryObject.Inventory[i].ItemId == args.carId) && (userInventoryObject.Inventory[i].CatalogVersion == "CarsProgress"))
    {
      carFound = true;
      //log.debug("car is in user's inventory!");
      car = userInventoryObject.Inventory[i];
      break;
    }
  }
  var cardInfo;
  for(i = 0; i < carCardsCatalog.Catalog.length; i++)
  {
    if(carCardsCatalog.Catalog[i].ItemId == args.carId)
    {
      cardInfo = JSON.parse(carCardsCatalog.Catalog[i].CustomData);
      //log.debug("cardInfo found!");
      break;
    }
  }

  if(cardInfo === undefined)
  return generateErrObj("CardNotFoundForCarwithID: " + args.carId + ". It is possible that the carCard ID and the Car ID do not coincide. Check Playfab catalog data.");

  if(carFound === true)
  {
    //test if maximum pr level was reached
    var newLvl = (parseInt(car.CustomData.CarLvl) + 1);
    if(newLvl >= Number(cardInfo.prPerLvl.length))
        return generateFailObj("Maximum pr level was reached!");

    var currCost = getObjectValueFromLevel(cardInfo, "currCostPerLvl", newLvl);
    var costCheckObj = checkBalance(cardInfo.currType, currCost, playerSC, playerHC);
    if(costCheckObj != "OK") return costCheckObj;


    //log.debug("user has enough currency. Let's check for card balance");

    var cardCost =  getObjectValueFromLevel(cardInfo, "cardCostPerLvl", newLvl);
    car.CustomData.CarLvl = newLvl;
    // log.debug("cardCost: " + cardCost);
    var cardFound = false;
    var cardData;
    for(i = 0; i < userInventoryObject.Inventory.length; i++)
    {
      if((userInventoryObject.Inventory[i].ItemId == args.carId) && (userInventoryObject.Inventory[i].CatalogVersion == "CarCards"))
      {
        // log.debug("consuming: " + userInventoryObject.Inventory[i].ItemInstanceId);
        cardFound = true;
        try
        {
          //old consume code
          // var itemConsumptionResult = server.ConsumeItem(
          //  {
          //    PlayFabId: currentPlayerId,
          //    ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
          //    ConsumeCount:cardCost
          //  }
          //);
          //new consume code
          if(userInventoryObject.Inventory[i].CustomData === undefined)//let's check if item has custom data
          {
            return generateFailObj("Insufficient cards, CusotmData undefined");
          }
          else
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount === undefined)//let's check if item has amount custom data
            {
              return generateFailObj("Insufficient cards, CusotmData.Amount udnefined");
            }
            else // let's check and see if the user has sufficent cards
            {
              if(Number(userInventoryObject.Inventory[i].CustomData.Amount) >= cardCost) // he does so let's remove the appropriate amount
              {
                userInventoryObject.Inventory[i].CustomData.Amount -= cardCost;
                cardData = {"Amount" : userInventoryObject.Inventory[i].CustomData.Amount};
                server.UpdateUserInventoryItemCustomData(
                  {
                    PlayFabId: currentPlayerId,
                    ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
                    Data: cardData
                  }
                );
              }
              else
              {
                return generateFailObj("Insufficient cards for real: " + userInventoryObject.Inventory[i].CustomData.Amount + " vs " + cardCost);
              }
            }
          }
        }
        catch(err)
        {
          //log.debug("itemConsumptionResult.errorCode " + err);
          return generateFailObj("Insufficient cards");
        }
        break;
      }
    }

    if(cardFound === false)
    {
      return generateFailObj("No cards found");
    }
    // log.debug("user has enough cards to purchase upgrade!");

    var newPr = recalculateCarPr(car.CustomData, car.ItemId, carCardsCatalog, undefined);
    // log.debug("upgrading to car lvl: " +  newLvl + " and pr: " + newPr);
    var CarData = {
      "CarLvl" : newLvl,
      "Pr" : newPr
    };
    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: car.ItemInstanceId,
        Data: CarData
      }
    );
    var subtractUserCurrencyResult;
    if(currCost > 0){
      subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
        {
          PlayFabId: currentPlayerId,
          VirtualCurrency : cardInfo.currType,
          Amount: currCost
        }
      );
    }
    // log.debug("Upgrade Complete!");

    var objectsUpdated =
    [
      {
        ItemId : args.carId,
        CatalogVersion: "CarCards",
        CustomData: cardData
      },
      {
        ItemId : args.carId,
        CatalogVersion: "CarsProgress",
        CustomData : CarData
      }
    ];

    var currencyUpdated = {};
    var i =
    {
      Inventory: objectsUpdated
    }
    if(subtractUserCurrencyResult!=undefined)
    {
      currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
      i.VirtualCurrency = currencyUpdated;
    }

    i.Experience = UpdateExperience("Balancing", "BalancingItem", "Car_" + cardInfo.rarity, newLvl, true);
    return generateInventoryChange("InventoryUpdate", i);
  }
  else
  {
    // log.debug("user doesn't have car: " +  args.carId + "... looking for card");
    var cardFound = false;
    var cardData;
    var carCardInstance;
    for(var i = 0; i < userInventoryObject.Inventory.length; i++)
    {
      if((userInventoryObject.Inventory[i].ItemId == args.carId) && (userInventoryObject.Inventory[i].CatalogVersion == "CarCards"))
      {
        //log.debug("consuming: " + userInventoryObject.Inventory[i].ItemInstanceId);
        cardFound = true;
        try
        {
          //old consume code
          //var itemConsumptionResult = server.ConsumeItem(
          // {
          //  PlayFabId: currentPlayerId,
          // ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
          //ConsumeCount: cardInfo.baseCardCost
          //  }
          //  );
          //new consume code
          if(userInventoryObject.Inventory[i].CustomData === undefined)//let's check if item has custom data
          {
            return generateFailObj("Insufficient cards, CustomData null");
          }
          else
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount === undefined)//let's check if item has amount custom data
            {
              return generateFailObj("Insufficient cards, CustomData.Amount null");
            }
            else // let's check and see if the user has sufficent cards
            {
              if(Number(userInventoryObject.Inventory[i].CustomData.Amount) >= Number(cardInfo.cardCostPerLvl[1])) // he does so let's remove the appropriate amount
              {
                carCardInstance = userInventoryObject.Inventory[i].ItemInstanceId;
                userInventoryObject.Inventory[i].CustomData.Amount -= cardInfo.cardCostPerLvl[1];
                cardData = {"Amount" : userInventoryObject.Inventory[i].CustomData.Amount};
              }
              else
              {
                return generateFailObj("Insufficient cards: " + userInventoryObject.Inventory[i].CustomData.Amount + " vs " + cardInfo.cardCostPerLvl[1] +".");
              }
            }
          }
        }
        catch(err)
        {
          return generateFailObj("Insufficient cards: " + err);
        }
        break;
      }
    }

    if(cardFound == false)
    {
      return generateFailObj("No cards found");
    }

    //log.debug("user has enough cards to purchase car. Checking if enough currency is availabe");

    var costCheckObj = checkBalance(cardInfo.currType, cardInfo.currCostPerLvl[1], playerSC, playerHC);
    if(costCheckObj != "OK") return costCheckObj;

    var itemsToGive = [];
    itemsToGive.push(args.carId);

    var carToGive = server.GrantItemsToUser(
      {
        CatalogVersion : "CarsProgress",
        PlayFabId: currentPlayerId,
        ItemIds : itemsToGive
      }
    );

    if(carToGive.ItemGrantResults[0].Result === false)
    {
      log.error("Something went wrong while giving user the item, refunding cards");
      //new refund code
      return generateFailObj("Something went wrong while giving user the item, refunding cards.");
    }
    else
    {
      server.UpdateUserInventoryItemCustomData(
        {
          PlayFabId: currentPlayerId,
          ItemInstanceId: carCardInstance,
          Data: cardData
        }
      );
    }
    var subtractUserCurrencyResult;
    if(cardInfo.currCostPerLvl[1] > 0){
      subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
        {
          PlayFabId: currentPlayerId,
          VirtualCurrency : cardInfo.currType,
          Amount: cardInfo.currCostPerLvl[1]
        }
      );
    }

    var CarData = {
      "CarLvl" : "1",
      "EngineLvl" : "0",
      "ExhaustLvl" : "0",
      "GearboxLvl" : "0",
      "SuspensionLvl" : "0"
    };

    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carToGive.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
    );
    CarData = {
      "TiresLvl" : "0",
      "TurboLvl" : "0",
      "PaintId" : cardInfo.defaultPaintID,
      "DecalId" : "0",
      "RimsId" : "0"
    };
    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carToGive.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
    );
    CarData = {
      "PlatesId" : "0",
      "WindshieldId" : "0",
      "Pr" : (Number(cardInfo.basePr) + cardInfo.prPerLvl[1])
    };

    server.UpdateUserInventoryItemCustomData(
      {
        PlayFabId: currentPlayerId,
        ItemInstanceId: carToGive.ItemGrantResults[0].ItemInstanceId,
        Data: CarData
      }
    );
    //if user doesn't have this paint job we give it to him/her
    var hasPaintJob = false;
    var hasPaintJobItem = false;
    var paintData;
    for(var i = 0; i < userInventoryObject.Inventory.length; i++)
    {
      if(userInventoryObject.Inventory[i].ItemId == "PaintJobs")
      {
        hasPaintJobItem = true;
        //log.debug("user has paintjobs");
        if(userInventoryObject.Inventory[i].CustomData != undefined)
        {
          // log.debug("user has paintjobs customData");
          if (cardInfo.defaultPaintID in userInventoryObject.Inventory[i].CustomData)
          {
            //log.debug("user has paintjob already");
            hasPaintJob = true;
          }
          else
          {
            // log.debug("user doesn't have paintjob");
            paintData = {}
            paintData[cardInfo.defaultPaintID] = "Owned";
          }
        }
        else // userInventoryObject.Inventory[i].CustomData == undefined
        {
          paintData = {}
          paintData[cardInfo.defaultPaintID] = "Owned";
        }
        if(paintData != undefined){
          server.UpdateUserInventoryItemCustomData(
            {
              PlayFabId: currentPlayerId,
              ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
              Data: paintData
            }
          );}
          break;
        }//end if "PaintJobs"
      }//end for

      if(hasPaintJobItem == false)
      {
        paintToGive = [];
        paintToGive.push("PaintJobs");
        var custToGive = server.GrantItemsToUser(
          {
            CatalogVersion : "Customization",
            PlayFabId: currentPlayerId,
            ItemIds : paintToGive
          }
        );

        var paintData = {};
        paintData[cardInfo.defaultPaintID] = "Owned";
        server.UpdateUserInventoryItemCustomData(
          {
            PlayFabId: currentPlayerId,
            ItemInstanceId: custToGive.ItemGrantResults[0].ItemInstanceId,
            Data: paintData
          }
        );

      }

      //create function result object for new car
      CarData = {
        "CarLvl" : "1",
        "EngineLvl" : "0",
        "ExhaustLvl" : "0",
        "GearboxLvl" : "0",
        "SuspensionLvl" : "0"    ,
        "TiresLvl" : "0",
        "TurboLvl" : "0",
        "PaintId" : cardInfo.defaultPaintID,
        "DecalId" : "0",
        "RimsId" : "0"   ,
        "PlatesId" : "0",
        "WindshieldId" : "0",
        "Pr" : Number(cardInfo.basePr) + cardInfo.prPerLvl[1]
      };
      var objectsUpdated =
      [
        {
          ItemId : args.carId,
          CatalogVersion: "CarCards",
          CustomData: cardData
        },
        {
          ItemId : args.carId,
          CatalogVersion: "CarsProgress",
          CustomData : CarData
        }
      ];

      if(hasPaintJob == false)
      {
        var paintDataUpdateObj = {};
        paintDataUpdateObj[cardInfo.defaultPaintID] = "Owned";
        var pObj =
        {
          ItemId : "PaintJobs",
          CatalogVersion: "Customization",
          CustomData : paintDataUpdateObj
        }
        objectsUpdated.push(pObj);
      }

      var currencyUpdated = {};

      i =
      {
        Inventory: objectsUpdated
      }
      if(subtractUserCurrencyResult != undefined)
      {
        currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
        i.VirtualCurrency =currencyUpdated;
      }

      i.Experience = UpdateExperience("Balancing", "BalancingItem", "Car_" + cardInfo.rarity, 1, true);
      return generateInventoryChange("InventoryUpdateNewCar", i);
    }
  }
function upgradePart(args, userInventoryObject, playerSC, playerHC)
{
  var carCatalog = server.GetCatalogItems(
    {
      CatalogVersion : "CarsProgress"
    }
  );

  var carExists = false;
  for(var i = 0; i < carCatalog.Catalog.length; i++)
  {
    if(carCatalog.Catalog[i].ItemId == args.carId)
    {
      carExists = true;
      break;
    }
  }

  if(carExists === false)
  return generateErrObj("car with ID: " + args.carId + " not found in catalog.");

  // log.debug("Checking to see if part exists in catalog");
  var partsCatalog = server.GetCatalogItems(
    {
      CatalogVersion : "PartCards"
    }
  );

  var partExists = false;
  var cardInfo;
  for(var i = 0; i < partsCatalog.Catalog.length; i++)
  {
    if(partsCatalog.Catalog[i].ItemId == args.partId)
    {
      cardInfo = JSON.parse(partsCatalog.Catalog[i].CustomData);
      partExists = true;
      break;
    }
  }


  if(partExists == false)
  return generateErrObj("part with ID: " + args.partId + " not found in catalog.");

  //log.debug("Checking to see if user has car: " + args.carId);
  var carFound = false;
  var car;
  for(var i = 0; i < userInventoryObject.Inventory.length; i++)
  {
    if((userInventoryObject.Inventory[i].ItemId == args.carId) && (userInventoryObject.Inventory[i].CatalogVersion == "CarsProgress"))
    {
      carFound = true;
      //log.debug("car is in user's inventory!");
      car = userInventoryObject.Inventory[i];
      break;
    }
  }

  if(carFound === false)
  {
    return generateFailObj("car with ID: " + args.carId + " not found in user inventory.");
  }
  // log.debug("Checking to see if user has part and or has enough parts");
  var partFound = false;
  var part;
  var newlvl = 0;
  var CarDataToBeUpdated = {};
  for(i = 0; i < userInventoryObject.Inventory.length; i++)
  {
    if((userInventoryObject.Inventory[i].ItemId == args.partId) && (userInventoryObject.Inventory[i].CatalogVersion == "PartCards"))
    {
      partFound = true;
      //log.debug("part is in user's inventory!");
      part = userInventoryObject.Inventory[i];
      var tempDict =
      {
        Exhaust: "ExhaustLvl",
        Engine: "EngineLvl",
        Gearbox:"GearboxLvl",
        Suspension: "SuspensionLvl",
        Tires: "TiresLvl",
        Turbo: "TurboLvl"
      };

      newlvl = parseInt(car.CustomData[tempDict[args.partId]]) + 1;

      //test if maximum pr level was reached
      if(newlvl >= Number(cardInfo.prPerLvl.length))
          return generateFailObj("Maximum pr level was reached!");

      var partsRequired = getObjectValueFromLevel(cardInfo, "cardCostPerLvl", newlvl);
      var currCost = getObjectValueFromLevel(cardInfo, "currCostPerLvl", newlvl);

      CarDataToBeUpdated[tempDict[args.partId]] = newlvl;
      car.CustomData[tempDict[args.partId]] = newlvl;
      // log.debug("we need: " + partsRequired + " cards and " + currCost + " money => base: " + parseInt(cardInfo.baseCurrCost) + " lvls: " + parseInt(car.CustomData[tempDict[args.partId]]) + " perLvlCost: " + parseInt(cardInfo.currCostPerLvl) + " equalling: "  + ((parseInt(car.CustomData[tempDict[args.partId]], 10) * parseInt(cardInfo.currCostPerLvl, 10))));
      var updateCardData;
      var costCheckObj = checkBalance(cardInfo.currType, currCost, playerSC, playerHC);
      if(costCheckObj != "OK") return costCheckObj;
      // log.debug("consuming part instance: " + userInventoryObject.Inventory[i].ItemInstanceId);
      try
      {
        if(userInventoryObject.Inventory[i].CustomData === undefined)//let's check if item has custom data
        {
          return generateFailObj("Insufficient cards");
        }
        else
        {
          if(userInventoryObject.Inventory[i].CustomData.Amount === undefined)//let's check if item has amount custom data
          {
            return generateFailObj("Insufficient cards");
          }
          else // let's check and see if the user has sufficent cards
          {
            if(userInventoryObject.Inventory[i].CustomData.Amount >= partsRequired) // he does so let's remove the appropriate amount
            {
              userInventoryObject.Inventory[i].CustomData.Amount -= partsRequired;
              updateCardData = {"Amount" : userInventoryObject.Inventory[i].CustomData.Amount};
              server.UpdateUserInventoryItemCustomData(
                {
                  PlayFabId: currentPlayerId,
                  ItemInstanceId: userInventoryObject.Inventory[i].ItemInstanceId,
                  Data: updateCardData
                }
              );
            }
            else
            {
              return generateFailObj("Insufficient cards");
            }
          }
        }
      }
      catch(err)
      {
        // log.debug("itemConsumptionResult.errorCode " + err);
        return generateFailObj("Insufficient cards");
      }
      break; //for search
    }//if in inventory

  }//for
  if(partFound == false)
  {
    return generateFailObj("Part not found");
  }
  var subtractUserCurrencyResult;
  if(currCost>0)
  {
    subtractUserCurrencyResult = server.SubtractUserVirtualCurrency(
      {
        PlayFabId: currentPlayerId,
        VirtualCurrency : cardInfo.currType,
        Amount: currCost
      }
    );
  }
  var newPr = recalculateCarPr(car.CustomData, car.ItemId, undefined, partsCatalog);
  CarDataToBeUpdated.Pr = newPr;

  server.UpdateUserInventoryItemCustomData(
    {
      PlayFabId: currentPlayerId,
      ItemInstanceId: car.ItemInstanceId,
      Data: CarDataToBeUpdated
    }
  );
  var objectsUpdated =
  [
    {
      ItemId : args.partId,
      CatalogVersion: "PartCards",
      CustomData: updateCardData
    },
    {
      ItemId : args.carId,
      CatalogVersion: "CarsProgress",
      CustomData : CarDataToBeUpdated
    }
  ];
  // log.debug("succesfully upgraded part!");



  var currencyUpdated = {};
  i ={Inventory: objectsUpdated};
  if(subtractUserCurrencyResult !== undefined)
  {
    currencyUpdated[subtractUserCurrencyResult.VirtualCurrency] = subtractUserCurrencyResult.Balance;
    i.VirtualCurrency = currencyUpdated;
  }

  i.Experience = UpdateExperience("Balancing", "BalancingItem", "Parts_" + cardInfo.rarity, newlvl, true);
  return generateInventoryChange("InventoryUpdatePart", i);
}
